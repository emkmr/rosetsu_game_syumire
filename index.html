<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <meta name="theme-color" content="#000000" />
  <title>ãƒ­ã‚»ãƒ„GAME2 â€” é–‹ç™ºç”¨ï¼ˆRauå®Ÿè£… + ã‚ªãƒ¼ãƒ—ãƒ‹ãƒ³ã‚°ä»˜ãï¼‰</title>

  <!-- PWA / Icons -->
  <link rel="manifest" href="manifest.webmanifest" />
  <link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192.png" />
  <link rel="icon" type="image/png" sizes="512x512" href="icons/icon-512.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon-180.png" />

  <!-- Fonts & Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700&family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet" />

  <style>
    body { font-family: 'Noto Sans JP', sans-serif; background:#000; margin:0; overflow:hidden; }

    /* --- Opening Styles --- */
    #openingSequence { position: relative; width: 100vw; height: 100vh; overflow: hidden; }
    .stars { position:absolute; inset:0; background:transparent; }
    .stars-small { background-image: radial-gradient(1px 1px at 20px 30px, #eee, rgba(0,0,0,0)), radial-gradient(1px 1px at 40px 70px, #fff, rgba(0,0,0,0)), radial-gradient(1px 1px at 50px 160px, #ddd, rgba(0,0,0,0)), radial-gradient(1px 1px at 90px 40px, #fff, rgba(0,0,0,0)), radial-gradient(1px 1px at 130px 80px, #fff, rgba(0,0,0,0)), radial-gradient(1px 1px at 160px 120px, #ddd, rgba(0,0,0,0)); background-size: 200px 200px; animation: zoom 25s infinite; }
    .stars-medium { background-image: radial-gradient(2px 2px at 50px 50px, #fff, rgba(0,0,0,0)), radial-gradient(2px 2px at 100px 100px, #ddd, rgba(0,0,0,0)), radial-gradient(2px 2px at 200px 150px, #fff, rgba(0,0,0,0)); background-size: 300px 300px; animation: zoom 40s infinite; }
    @keyframes zoom { 0% { transform: scale(1);} 50% { transform: scale(1.2);} 100% { transform: scale(1);} }
    .perspective-container { position:absolute; inset:0; perspective: 400px; perspective-origin: 50% 60%; }
    .crawl-container { position:absolute; top:100%; width:80%; max-width:800px; left:50%; transform:translateX(-50%); transform-origin:50% 100%; animation:crawl 50s linear forwards; }
    .crawl-content { color:#feda4a; font-size:5.5vw; line-height:1.4; text-align:justify; font-weight:bold; transform: rotateX(20deg); }
    .crawl-episode-title { text-align:center; font-size:6vw; margin-bottom:2em; line-height:1.2; }
    @media (min-width:768px){ .crawl-content{font-size:42px;} .crawl-episode-title{font-size:48px;} }
    @keyframes crawl { from{top:100%;} to{top:-200%;} }
    .game-title-opening { position:absolute; top:50%; left:50%; color:#feda4a; font-weight:bold; text-align:center; opacity:0; transform: translate(-50%,-50%) scale(1.5); animation:titleZoom 7s forwards; }
    .main-title { font-size:10vw; white-space:nowrap; }
    @media (min-width:768px){ .main-title{font-size:72px;} }
    @keyframes titleZoom { 0%{opacity:1; transform: translate(-50%,-50%) scale(1.5);} 80%{opacity:1;} 100%{opacity:0; transform: translate(-50%,-50%) scale(0.1);} }
    .initial-text { position:absolute; top:50%; left:5%; transform:translateY(-50%); color:#49dafd; font-size:7vw; font-weight:bold; text-align:left; opacity:0; animation:initialFade 5s forwards; }
    @media (min-width:768px){ .initial-text{font-size:3em;} }
    @keyframes initialFade { 0%{opacity:0;} 20%{opacity:1;} 80%{opacity:1;} 100%{opacity:0;} }

    /* --- Game Styles --- */
    .game-body { background:#f0f0f0; }
    #gameCanvas { display:block; background:#eaeaea; border:2px solid #333; border-radius:8px; box-shadow:0 4px 6px rgba(0,0,0,.1); image-rendering: pixelated; width:100%; height:auto; touch-action:none; }
    .control-btn { transition: all .1s ease-in-out; user-select:none; }
    .control-btn:active { transform: scale(.92); }
    .dialogue-box { animation: slide-up .28s ease-out forwards; }
    @keyframes slide-up { from{ transform: translateY(100%); opacity:0;} to{ transform: translateY(0); opacity:1;} }
    :root { --safe-bottom: env(safe-area-inset-bottom); }
    #controls { padding-bottom: calc(var(--safe-bottom,0) + .25rem); }
    #btn-up, #btn-down, #btn-left, #btn-right { display:none; }
    * { -webkit-user-select: none; user-select: none; }
    #controls{ position:fixed; inset:auto 12px calc(env(safe-area-inset-bottom) + 12px) auto; width:auto; display:block; background:transparent; box-shadow:none; z-index:25; }
    #btn-action{ padding:14px 18px; border-radius:9999px; font-weight:700; }

    /* === 6-bit Binary Overlay === */
    .binaryOverlay { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(0,0,0,0.75); z-index: 999; }
    .binaryBox { font: 700 clamp(28px, 6vw, 64px)/1 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; letter-spacing: .08em; color: #a0ffcb; text-shadow: 0 0 20px rgba(160,255,203,0.45); text-align:center; }
    .binarySub { font: 500 clamp(12px, 2vw, 18px)/1.4 system-ui, -apple-system, 'Segoe UI', Roboto, 'Noto Sans JP', sans-serif; color: #b8ffd9; opacity: .85; margin-top: .6em; }
  </style>
</head>
<body>
  <!-- Opening Sequence (ã‚¯ãƒªãƒƒã‚¯/ã‚¿ãƒƒãƒ—ã§ã‚¹ã‚­ãƒƒãƒ—å¯èƒ½) -->
  <div id="openingSequence">
    <div id="starsContainer" style="display:none;">
      <div class="stars stars-small"></div>
      <div class="stars stars-medium"></div>
    </div>
    <div id="initialText" class="initial-text">
      <p>é ã„æ˜”ã€€ã€€ã¯ã‚‹ã‹ã‹ãªãŸã®</p>
      <p>éŠ€æ²³ç³»ã§ãƒ»ãƒ»ãƒ»</p>
    </div>
    <div id="gameTitleOpening" class="game-title-opening" style="display:none;">
      <p class="main-title">Rosetsu and the Simulated World</p>
    </div>
    <div id="perspectiveContainer" class="perspective-container" style="display:none;">
      <div id="crawlContainer" class="crawl-container">
        <div class="crawl-content">
          <h3 class="crawl-episode-title">ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰ï¼”<br>æ–°ãŸãªã‚‹è¦šé†’</h3>
          <p>å®‡å®™ã¯ã€è¦‹ãˆã–ã‚‹æ‰‹ã«ã‚ˆã£ã¦ç·¨ã¾ã‚ŒãŸç²¾å·§ãªå¹»å½±ã ã£ãŸã€‚</p>
          <p>&nbsp;</p>
          <p>ç„¡æ•°ã®æ˜Ÿã€…ãŒè¼ãéŠ€æ²³ã®å½¼æ–¹ã§ã€ãã®å¹»å½±ã¯ä»Šã€ç¶»ã³å§‹ã‚ã¦ã„ã‚‹ã€‚</p>
          <p>&nbsp;</p>
          <p>ãã‚Œã¯å°ã•ãªç•°å¤‰ã‹ã‚‰å§‹ã¾ã£ãŸã€‚é£Ÿã¹ã¦ã‚‚æ¸›ã‚‰ã¬ãƒ‰ãƒƒã‚°ãƒ•ãƒ¼ãƒ‰ã€èã“ãˆã‚‹ã¯ãšã®ãªã„é›»å­éŸ³ã€ãã—ã¦å§¿ã‚’å¤‰ãˆã‚‹è¡—ã®æ™¯è‰²ã€‚</p>
          <p>&nbsp;</p>
          <p>ç™½ããƒãƒ¯ãƒ¯ã€ãƒ­ã‚»ãƒ„ã€‚å½¼ã®é‹­æ•ãªå—…è¦šã¨è´è¦šã¯ã€äººé¡ãŒæ±ºã—ã¦æ„ŸçŸ¥ã§ãã¬ä¸–ç•Œã®â€œãƒã‚°â€ã‚’æ‰ãˆãŸã€‚</p>
          <p>&nbsp;</p>
          <p>ç¶»ã³ã¯æ‹¡å¤§ã—ã€ã‚„ãŒã¦å…¨ã¦ã®è¨˜æ†¶ã¨å­˜åœ¨ã‚’ãƒ‡ãƒ¼ã‚¿ã®å½¼æ–¹ã¸ã¨æŠ¼ã—æµã™ã ã‚ã†ã€‚ãã®é‹å‘½ã‚’é˜»ã‚€è€…ã¯ã€ãŸã ä¸€åŒ¹â€”â€”ã€‚</p>
          <p>&nbsp;</p>
          <p>é¯¨å²¡å®¶ã‚’å®ˆã‚‹ãŸã‚ã€ãã—ã¦çœŸå®Ÿã‚’æ˜ã‚‰ã‹ã«ã™ã‚‹ãŸã‚ã€ãƒ­ã‚»ãƒ„ã¯æœªçŸ¥ãªã‚‹å®‡å®™ã®æ·±å±¤ã¸ã¨æ—…ç«‹ã¤ã€‚å½¼ã®å†’é™ºã¯ã€ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®å¢ƒç•Œç·šã‚’è¶Šãˆã€ä¸–ç•Œã®è¨­è¨ˆå›³ãã®ã‚‚ã®ã«è¿«ã‚‹ã“ã¨ã¨ãªã‚‹ã€‚</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Main Game (ã‚ªãƒ¼ãƒ—ãƒ‹ãƒ³ã‚°å¾Œã«è¡¨ç¤º) -->
  <div id="mainGame" style="display:none;" class="flex flex-col items-center justify-center min-h-screen p-4">
    <div id="game-container" class="w-full max-w-2xl mx-auto">
      <h1 class="text-xl sm:text-2xl font-bold text-center text-gray-800 mb-3">Rosetsu and the Simulated World</h1>
      <canvas id="gameCanvas"></canvas>
    </div>
    <div id="dialogue-container" class="fixed left-0 right-0 p-3 flex justify-center z-30 pointer-events-none"></div>
    <div id="controls" class="fixed bottom-0 left-0 right-0 grid grid-cols-3 gap-2 w-full max-w-sm mx-auto p-3 z-20">
      <div></div>
      <button id="btn-up" class="control-btn bg-gray-700 text-white p-4 rounded-2xl shadow-md">â†‘</button>
      <div></div>
      <button id="btn-left" class="control-btn bg-gray-700 text-white p-4 rounded-2xl shadow-md">â†</button>
      <button id="btn-down" class="control-btn bg-gray-700 text-white p-4 rounded-2xl shadow-md">â†“</button>
      <button id="btn-right" class="control-btn bg-gray-700 text-white p-4 rounded-2xl shadow-md">â†’</button>
      <button id="btn-action" class="control-btn bg-lime-500 text-white p-4 rounded-2xl shadow-md col-span-3">TALK / CHECK</button>
    </div>
  </div>

  <!-- === 6-bit Binary Overlay (DOM) === -->
  <div id="binaryOverlay" class="binaryOverlay">
    <div>
      <div id="binaryText" class="binaryBox">000001</div>
      <div class="binarySub">ä¸–ç•Œã®ã‚³ãƒ¼ãƒ‰ãŒå……å¡«ã•ã‚Œã¦ã„ã¾ã™â€¦</div>
    </div>
  </div>

  <script type="module">
    // ===== Opening refs & control =====
    const openingSequence = document.getElementById('openingSequence');
    const initialText = document.getElementById('initialText');
    const gameTitleOpening = document.getElementById('gameTitleOpening');
    const perspectiveContainer = document.getElementById('perspectiveContainer');
    const mainGame = document.getElementById('mainGame');
    const starsContainer = document.getElementById('starsContainer');

    let openingSkipped = false;
    const skipOpening = () => {
      if (openingSkipped) return; openingSkipped = true;
      openingSequence.style.display = 'none';
      document.body.classList.add('game-body');    // èƒŒæ™¯ã‚’ã‚²ãƒ¼ãƒ ç”¨ã¸
      mainGame.style.display = 'flex';             // ã‚²ãƒ¼ãƒ è¡¨ç¤º
      layoutCanvas();                               // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºèª¿æ•´
      startGame();                                  // â† ã‚²ãƒ¼ãƒ é–‹å§‹ã¯ã“ã“ã ã‘ã§å‘¼ã¶
    };
    // ã‚¯ãƒªãƒƒã‚¯/ã‚¿ãƒƒãƒ—ã§ã‚¹ã‚­ãƒƒãƒ—
    openingSequence.addEventListener('click', skipOpening);
    openingSequence.addEventListener('touchstart', skipOpening, {passive:true});
    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é·ç§»
    initialText.addEventListener('animationend', () => {
      if (openingSkipped) return;
      initialText.style.display='none';
      starsContainer.style.display='block';
      gameTitleOpening.style.display='block';
    });
    gameTitleOpening.addEventListener('animationend', () => {
      if (openingSkipped) return;
      gameTitleOpening.style.display='none';
      perspectiveContainer.style.display='block';
    });
    document.querySelector('#perspectiveContainer .crawl-container')
      .addEventListener('animationend', () => { if (!openingSkipped) skipOpening(); });

    // ===== DOM refs (game) =====
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const dialogueEl = document.getElementById('dialogue-container');

    // --- Safety patch: guard canvas arc/ellipse radii (fixes negative/zero radius IndexSizeError) ---
    const __ARC_MIN__ = 0.001;
    (function patchCanvasGuards(c){
      const arc0 = c.arc.bind(c);
      c.arc = function(x,y,r,sa,ea,ac){
        let rr = Number.isFinite(r) ? Math.abs(r) : __ARC_MIN__;
        if (rr < __ARC_MIN__) rr = __ARC_MIN__;
        return arc0(x,y,rr,sa,ea,ac);
      };
      const el0 = c.ellipse.bind(c);
      c.ellipse = function(x,y,rx,ry,rot,sa,ea,ac){
        let rxx = Number.isFinite(rx) ? Math.abs(rx) : __ARC_MIN__;
        let ryy = Number.isFinite(ry) ? Math.abs(ry) : __ARC_MIN__;
        if (rxx < __ARC_MIN__) rxx = __ARC_MIN__;
        if (ryy < __ARC_MIN__) ryy = __ARC_MIN__;
        return el0(x,y,rxx,ryy,rot,sa,ea,ac);
      };
    })(ctx);

    // === 6-bit DOM ===
    const binaryOverlay = document.getElementById('binaryOverlay');
    const binaryText = document.getElementById('binaryText');

    // ===== Layout (iPhoneè€ƒæ…®) =====
    const camera = { x:0, y:0, w:0, h:0, dpr:1 };
    function layoutCanvas(){
      const desiredHeight = Math.max(260, window.innerHeight - 24);
      const desiredWidth  = Math.min(window.innerWidth, 820);
      const dpr = Math.min(window.devicePixelRatio || 1, 2);
      canvas.style.width = desiredWidth + 'px';
      canvas.style.height = desiredHeight + 'px';
      canvas.width  = Math.floor(desiredWidth * dpr);
      canvas.height = Math.floor(desiredHeight * dpr);
      camera.w = desiredWidth; camera.h = desiredHeight; camera.dpr = dpr;
      dialogueEl.style.bottom = '';
      dialogueEl.style.top = 'calc(env(safe-area-inset-top) + 8px)';
    }

    // ===== World =====
    const TILE_SIZE = 48;
    const WORLD_COLS = 60;
    const WORLD_ROWS = 40;
    const map = Array.from({ length: WORLD_ROWS }, (_, y) => (
      Array.from({ length: WORLD_COLS }, (_, x) => (y===0||y===WORLD_ROWS-1||x===0||x===WORLD_COLS-1)?1:0)
    ));
    function addBlock(x,y,w,h,id){ for(let j=0;j<h;j++){ for(let i=0;i<w;i++){ map[y+j][x+i]=id; }}}
    addBlock(8,6,6,3,3);
    addBlock(16,12,4,7,4);
    addBlock(27,9,5,5,3);
    addBlock(40,20,8,4,4);
    addBlock(45,30,5,5,3);
    addBlock(12,28,7,4,4);

    const START_TX = 4, START_TY = WORLD_ROWS - 6;

    // ===== State =====
    const player = { x: START_TX*TILE_SIZE, y: START_TY*TILE_SIZE, size:TILE_SIZE*0.9, speed:4.2, isMoving:false };
    const keys = {}; let gameStarted=true; let tetsujiQuestAccepted=false; let dialogueTimeout;

    let anomalies = []; // {x,y,age,life,maxR,hit:false,rings:3}
    let anomalyTimer = 0; // æ¬¡ã®ã‚¹ãƒãƒ¼ãƒ³ã¾ã§ã®æ®‹ã‚Šms
    const flash = { t:0, dur:0, stars:[], cb:null }; // ãƒ”ãƒ³ã‚¯å®‡å®™
    let inputLockedUntil = 0;

    // 1å›ã ã‘ãƒ”ãƒ³ã‚¯å®‡å®™ã«ã™ã‚‹
    let pinkSeen = false;

    // ãƒ›ãƒ¯ã‚¤ãƒˆãƒãƒ¼ã‚¹ãƒˆï¼ˆãƒãƒ©å°‚ç”¨ï¼‰
    const bursts = []; // {x,y,age,dur,ringR}

    // ã‚¿ãƒƒãƒ—ç§»å‹•
    const touch = { active:false, wx:0, wy:0 };

    const npcs = [
      { id:'komaru', type:5, x:(START_TX+2)*TILE_SIZE, y:(START_TY)*TILE_SIZE, size:TILE_SIZE*0.9, speed:1.2, vx:0, vy:0, homeX:null, homeY:null, wander:0, radius:TILE_SIZE*6, dialogue:'ãƒ­ã‚»ã¡ã‚ƒã‚“ã€‚ã“ã®ä¸–ç•Œã®ãƒã‚°ã¯ã€ã‚¿ãƒ•ã‚¬ã‚¤ãªã‚‰ã™ãã«è¦‹ã¤ã‘ã‚‰ã‚Œã‚‹ã¯ãšï¼' },
      { id:'tetsuji', type:6, x:(START_TX+5)*TILE_SIZE, y:(START_TY-2)*TILE_SIZE, size:TILE_SIZE,   speed:1.0, vx:0, vy:0, homeX:null, homeY:null, wander:0, radius:TILE_SIZE*6, dialogue:'ã†ã…â€¦é¦–è¼ªã«ã¤ã„ã¦ãŸã‚‚ã‚‚ã¡ã‚ƒã‚“ã«ã‚‚ã‚‰ã£ãŸå¤§äº‹ãªé‡çƒãƒœãƒ¼ãƒ«ãŒã€å¤‰ãªå…‰ã¨å…±ã«ãªããªã£ã¡ã‚ƒã£ãŸã‚“ã â€¦' }
    ];
    npcs.forEach(n=>{ n.homeX=n.x; n.homeY=n.y; });

    const glitches = [
      { id:'normal', x:(START_TX+8)*TILE_SIZE, y:(START_TY-4)*TILE_SIZE, size:TILE_SIZE, fixed:false },
      { id:'normal', x:33*TILE_SIZE, y:18*TILE_SIZE, size:TILE_SIZE, fixed:false },
      { id:'ball',   x:44*TILE_SIZE, y:26*TILE_SIZE, size:TILE_SIZE, fixed:false, vx:0, vy:0, flicker:0, state:'idle', timer:0, immune:0 }
    ];

    // === Roses (6æœ¬ãƒ»ãƒ¢ãƒã‚¯ãƒ­) ===
    const ROSE_TARGET = 6;
    const roses = [
      {x: 10*TILE_SIZE, y:  9*TILE_SIZE, taken:false},
      {x: 22*TILE_SIZE, y: 15*TILE_SIZE, taken:false},
      {x: 36*TILE_SIZE, y: 10*TILE_SIZE, taken:false},
      {x: 12*TILE_SIZE, y: 26*TILE_SIZE, taken:false},
      {x: 44*TILE_SIZE, y: 32*TILE_SIZE, taken:false},
      {x: 52*TILE_SIZE, y: 14*TILE_SIZE, taken:false},
    ];
    let roseCount = 0;

    // === Grid Fragmentsï¼ˆæ ¼å­ç‰‡ï¼‰ ===
    const GRID_TARGET = 6;
    const gridFragments = [
      {x: 18*TILE_SIZE, y:  8*TILE_SIZE, taken:false},
      {x: 30*TILE_SIZE, y: 16*TILE_SIZE, taken:false},
      {x: 41*TILE_SIZE, y: 11*TILE_SIZE, taken:false},
      {x: 14*TILE_SIZE, y: 22*TILE_SIZE, taken:false},
      {x: 47*TILE_SIZE, y: 28*TILE_SIZE, taken:false},
      {x: 55*TILE_SIZE, y: 13*TILE_SIZE, taken:false},
    ];
    let gridCount = 0;

    // === Revelationï¼ˆä¸–ç•Œã®çš®è†œï¼‰===
    const revelation = { t:0, dur:2600, slow:0.35 };
    let desaturatePalette = 0; // 0..1

    // === 6-bit state ===
    let sixBitPlayed = false; // ä¸€åº¦ã ã‘

    // === Grid FX (pickupæ™‚ã®ä¸€æ™‚çš„ãªæ ¼å­ã‚·ãƒãƒ¼) ===
    const gridFX = { t:0, dur:900, phase:0 };

    // Mapã«NPCã‚’ã‚½ãƒªãƒƒãƒ‰é…ç½®
    npcs.forEach(n=>{ const tx=Math.floor(n.x/TILE_SIZE), ty=Math.floor(n.y/TILE_SIZE); map[ty][tx]=n.type; });

    // ===== Camera =====
    const world = { w: WORLD_COLS*TILE_SIZE, h: WORLD_ROWS*TILE_SIZE };
    function clampCamera(px,py){
      const mx = camera.w*0.35, my = camera.h*0.35; let tx = px - camera.w/2, ty = py - camera.h/2;
      if (px < camera.x + mx) tx = px - mx; if (px > camera.x + camera.w - mx) tx = px + mx - camera.w;
      if (py < camera.y + my) ty = py - my; if (py > camera.y + camera.h - my) ty = py + my - camera.h;
      camera.x = Math.max(0, Math.min(world.w - camera.w, tx)); camera.y = Math.max(0, Math.min(world.h - camera.h, ty));
    }

    // ===== Utilities =====
    const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
    const dist=(ax,ay,bx,by)=>Math.hypot(ax-bx, ay-by);
    const rand=(a,b)=>a+Math.random()*(b-a);
    const isOnScreen = (x,y) => (
  x >= camera.x && x <= camera.x + camera.w &&
  y >= camera.y && y <= camera.y + camera.h
);

    function isBlocked(actor, x, y, size){
      const margin=2;
      const corners=[
        {x:x+margin, y:y+margin},
        {x:x+size-margin, y:y+margin},
        {x:x+margin, y:y+size-margin},
        {x:x+size-margin, y:y+size-margin}
      ];
      for(const c of corners){
        const tx=Math.floor(c.x/TILE_SIZE), ty=Math.floor(c.y/TILE_SIZE);
        const id=map[ty]?.[tx];
        if(id===1||id===3||id===4) return true; // å£ãƒ»éšœå®³ç‰©
        if(actor==='player' && (id===5||id===6)) return true; // NPC
      }
      return false;
    }

    // ===== Dialogue UI =====
    function showDialogue(text, duration=3000, speaker='ãƒ­ã‚»ãƒ„', isEnd=false){
      clearTimeout(dialogueTimeout);
      let color='text-pink-500'; if(speaker==='komaru') color='text-green-600'; if(speaker==='tetsuji') color='text-yellow-700'; if(speaker==='ã‚·ã‚¹ãƒ†ãƒ ') color='text-blue-600'; if(speaker==='rau') color='text-purple-600';
      const speakerName = { komaru:'ã‚³ãƒãƒ«å…ˆè¼©', tetsuji:'é‰„äºŒ', 'ãƒ­ã‚»ãƒ„':'ãƒ­ã‚»ãƒ„', 'ã‚·ã‚¹ãƒ†ãƒ ':'ã‚·ã‚¹ãƒ†ãƒ ', 'rau':'ãƒ©ã‚¦' }[speaker] || 'ãƒ­ã‚»ãƒ„';
      const html = `
        <div class="dialogue-box bg-white bg-opacity-95 p-3 rounded-xl shadow-xl border-2 border-gray-300 max-w-md w-[92%] pointer-events-auto">
          <p class="text-gray-800 font-bold"><span class="${color}">${speakerName}:</span> ${text}</p>
          ${isEnd?'<p class="text-center text-sm mt-2 text-blue-600">ã‚¯ãƒªã‚¢ãŠã‚ã§ã¨ã†ï¼ - ãƒšãƒ¼ã‚¸ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ</p>':''}
        </div>`;
      dialogueEl.innerHTML = html; dialogueTimeout = setTimeout(()=>{ dialogueEl.innerHTML=''; }, duration);
    }

    // ===== Input =====
    function setupControls(){
      document.getElementById('btn-action').addEventListener('click', e=>{ e.preventDefault(); if(!gameStarted) gameStarted=true; interact(); });
      window.addEventListener('keydown', e=>{ if(e.key.startsWith('Arrow')){ keys[e.key]=true; if(!gameStarted) gameStarted=true; }
        // ãƒ‡ãƒãƒƒã‚°: P=ãƒ”ãƒ³ã‚¯å®‡å®™, B=6bitæ¼”å‡º, G=æ ¼å­ç‰‡ãƒ¡ã‚¬ã‚°ãƒªãƒƒãƒ‰, O=ãƒ©ã‚¦å¾®ãƒ•ãƒªãƒƒã‚«ãƒ¼
        if(e.key.toLowerCase()==='p'){ triggerFlash(true); }
        if(e.key.toLowerCase()==='b'){ if(!sixBitPlayed) triggerBinarySequence(true); }
        if(e.key.toLowerCase()==='g'){ if(gridCount>=GRID_TARGET) triggerMegaGrid(); }
        if(e.key.toLowerCase()==='o'){ rau.flicker = Math.max(rau.flicker, 1); }
      });
      window.addEventListener('keyup',   e=>{ if(e.key.startsWith('Arrow')) keys[e.key]=false; });

      const toWorld = (e) => {
        const r = canvas.getBoundingClientRect();
        const sx = (e.clientX - r.left) * (canvas.width / r.width);
        const sy = (e.clientY - r.top) * (canvas.height / r.height);
        return { wx: sx / camera.dpr + camera.x, wy: sy / camera.dpr + camera.y };
      };

      const tryAnomalyHit = (p)=>{
        const tol = 36; // ãƒ’ãƒƒãƒˆè¨±å®¹å¹…
        for(const a of anomalies){
          if(a.hit) continue;
          const dc = Math.hypot(p.wx-a.x, p.wy-a.y);
          if(dc < 20){ a.hit=true; triggerFlash(); return true; }
          for(let i=0;i<(a.rings||1);i++){
            const phase = (a.age/a.life + i/(a.rings||1)) % 1;
            const ring = a.maxR * phase;
            if(Math.abs(dc - ring) < tol){ a.hit=true; triggerFlash(); return true; }
          }
        }
        return false;
      };

      const start = (e) => { e.preventDefault(); const p=toWorld(e); if(tryAnomalyHit(p)) { touch.active=false; return; } touch.active=true; touch.wx=p.wx; touch.wy=p.wy; if(!gameStarted) gameStarted=true; };
      const move  = (e) => { if(!touch.active) return; e.preventDefault(); const p=toWorld(e); touch.wx=p.wx; touch.wy=p.wy; };
      const end   = () => { touch.active=false; };

      canvas.addEventListener('pointerdown', start, {passive:false});
      canvas.addEventListener('pointermove',  move,  {passive:false});
      window.addEventListener('pointerup', end);
      window.addEventListener('pointercancel', end);
    }

    // ===== Draw: Map & Entities =====
    function drawMap(){
      const sc=Math.max(0,Math.floor(camera.x/TILE_SIZE)-1), ec=Math.min(WORLD_COLS-1,Math.ceil((camera.x+camera.w)/TILE_SIZE)+1);
      const sr=Math.max(0,Math.floor(camera.y/TILE_SIZE)-1), er=Math.min(WORLD_ROWS-1,Math.ceil((camera.y+camera.h)/TILE_SIZE)+1);
      for(let y=sr;y<=er;y++) for(let x=sc;x<=ec;x++){ const id=map[y][x]; let color='#a3bf8f'; if(id===1) color='#7a6855'; else if(id===3) color='#8aab79'; else if(id===4) color='#6b8e23'; ctx.fillStyle=color; ctx.fillRect(x*TILE_SIZE,y*TILE_SIZE,TILE_SIZE,TILE_SIZE); }
    }

    // Roses
    function drawRose(r){
      const s = TILE_SIZE*0.5; ctx.save(); ctx.translate(r.x + TILE_SIZE/2, r.y + TILE_SIZE/2);
      ctx.fillStyle = '#777'; ctx.strokeStyle = '#ccc'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(0, -s*0.2, Math.max(__ARC_MIN__, s*0.35), 0, Math.PI*2); ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(-s*0.2, -s*0.25); ctx.quadraticCurveTo(0, -s*0.45, s*0.2, -s*0.25); ctx.quadraticCurveTo(0, -s*0.05, -s*0.2, -s*0.25); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0, -s*0.0); ctx.lineTo(0, s*0.45); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0, s*0.2); ctx.quadraticCurveTo(s*0.25, s*0.15, s*0.18, 0); ctx.quadraticCurveTo(s*0.1, s*0.18, 0, s*0.2); ctx.fillStyle='#666'; ctx.fill(); ctx.stroke();
      ctx.restore();
    }
    function drawRoses(){ roses.forEach(r=>{ if(!r.taken) drawRose(r); }); }

    // ãƒãƒ©ç²å¾—ãƒãƒ¼ã‚¹ãƒˆ
    function triggerWhiteBurst(x,y){ bursts.push({x,y,age:0,dur:700,ringR:0}); }
    function updateBursts(dt){ for(let i=bursts.length-1;i>=0;i--){ const b=bursts[i]; b.age+=dt; b.ringR += dt*0.12*TILE_SIZE; if(b.age>b.dur) bursts.splice(i,1); } }
    function drawBursts(){ if(!bursts.length) return; ctx.save(); ctx.setTransform(camera.dpr,0,0,camera.dpr,0,0); ctx.translate(-camera.x,-camera.y); bursts.forEach(b=>{ const t = Math.max(0, 1 - b.age/b.dur); ctx.save(); ctx.globalAlpha = 0.5*t + 0.2; ctx.beginPath(); ctx.arc(b.x, b.y, Math.max(__ARC_MIN__, 18 + 30*(1-t)), 0, Math.PI*2); ctx.fillStyle='white'; ctx.fill(); ctx.globalCompositeOperation='lighter'; ctx.globalAlpha = 0.35*t; const grd = ctx.createRadialGradient(b.x,b.y,10,b.x,b.y,90); grd.addColorStop(0,'rgba(255,255,255,0.9)'); grd.addColorStop(1,'rgba(255,255,255,0)'); ctx.beginPath(); ctx.arc(b.x, b.y, 90, 0, Math.PI*2); ctx.fillStyle=grd; ctx.fill(); ctx.globalAlpha = 0.55*t; ctx.lineWidth = 3; ctx.strokeStyle = 'rgba(255,255,255,0.9)'; ctx.beginPath(); ctx.arc(b.x, b.y, Math.max(__ARC_MIN__, 20 + b.ringR), 0, Math.PI*2); ctx.stroke(); ctx.restore(); }); ctx.restore(); }

    // Rosetsu & NPCs
    function drawRosetsu(p){ ctx.save(); ctx.translate(p.x+p.size/2, p.y+p.size/2); if(p.isMoving) ctx.translate(0, Math.sin(Date.now()/100)*2); ctx.fillStyle='white'; ctx.strokeStyle='black'; ctx.lineWidth=2; ctx.beginPath(); ctx.ellipse(0,p.size*0.1,p.size*0.28,p.size*0.4,0,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.ellipse(0,-p.size*0.2,p.size*0.35,p.size*0.25,0,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(-p.size*0.2,-p.size*0.3); ctx.quadraticCurveTo(-p.size*0.4,-p.size*0.5,-p.size*0.3,-p.size*0.15); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(p.size*0.2,-p.size*0.3); ctx.quadraticCurveTo(p.size*0.4,-p.size*0.5,p.size*0.3,-p.size*0.15); ctx.fill(); ctx.stroke(); ctx.fillStyle='black'; ctx.beginPath(); ctx.arc(-p.size*0.1,-p.size*0.2, 1.6, 0, Math.PI*2); ctx.arc(p.size*0.1,-p.size*0.2, 1.6, 0, Math.PI*2); ctx.arc(0,-p.size*0.15, 1.6, 0, Math.PI*2); ctx.fill(); ctx.fillStyle='#FF9800'; ctx.beginPath(); ctx.ellipse(0,p.size*0.15,p.size*0.05,p.size*0.12,0,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#FF7043'; ctx.beginPath(); ctx.moveTo(0,p.size*0.05); ctx.lineTo(-p.size*0.08,p.size*0.02); ctx.lineTo(p.size*0.08,p.size*0.02); ctx.closePath(); ctx.fill(); ctx.restore(); }
    function drawKomaru(n){ ctx.save(); ctx.translate(n.x+TILE_SIZE/2, n.y+TILE_SIZE/2); const p={size:TILE_SIZE*.9}; ctx.fillStyle='white'; ctx.strokeStyle='black'; ctx.lineWidth=2; ctx.beginPath(); ctx.ellipse(0,p.size*.15,p.size*.28,p.size*.4,0,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.ellipse(0,-p.size*.2,p.size*.35,p.size*.25,0,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(-p.size*.2,-p.size*.3); ctx.quadraticCurveTo(-p.size*.4,-p.size*.45,-p.size*.35,-p.size*.15); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(p.size*.2,-p.size*.3); ctx.quadraticCurveTo(p.size*.4,-p.size*.45,p.size*.35,-p.size*.15); ctx.fill(); ctx.stroke(); ctx.fillStyle='black'; ctx.beginPath(); ctx.arc(-p.size*.12,-p.size*.2, 1.5, 0, Math.PI*2); ctx.arc(p.size*.12,-p.size*.2, 1.5, 0, Math.PI*2); ctx.arc(0,-p.size*.15, 1.5, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle='black'; ctx.lineWidth=1.5; ctx.beginPath(); ctx.moveTo(-p.size*.1,-p.size*.1); ctx.quadraticCurveTo(0,-p.size*.07,p.size*.1,-p.size*.1); ctx.stroke(); ctx.restore(); }
    function drawTetsuji(n){ ctx.save(); ctx.translate(n.x+TILE_SIZE/2, n.y+TILE_SIZE/2); const p={size:TILE_SIZE}; ctx.fillStyle='#f5deb3'; ctx.strokeStyle='black'; ctx.lineWidth=2; ctx.beginPath(); ctx.ellipse(0,p.size*.25,p.size*.5,p.size*.3,0,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.ellipse(0,-p.size*.1,p.size*.4,p.size*.28,0,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.ellipse(-p.size*.35,-p.size*.1,p.size*.16,p.size*.14,0,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.ellipse(p.size*.35,-p.size*.1,p.size*.16,p.size*.14,0,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.fillStyle='#3d3532'; ctx.beginPath(); ctx.ellipse(0,0,p.size*.25,p.size*.1,0,0,Math.PI*2); ctx.fill(); ctx.fillStyle='black'; ctx.beginPath(); ctx.arc(-p.size*.15,-p.size*.12, Math.max(__ARC_MIN__, p.size*.05), 0, Math.PI*2); ctx.arc(p.size*.15,-p.size*.12, Math.max(__ARC_MIN__, p.size*.05), 0, Math.PI*2); ctx.arc(0,p.size*.02, Math.max(__ARC_MIN__, p.size*.04), 0, Math.PI*2); ctx.fill(); ctx.restore(); }
    function drawNPCs(){ npcs.forEach(n=>{ if(n.id==='komaru') drawKomaru(n); else drawTetsuji(n); }); }

    // Glitches
    function drawGlitches(){ const colors=['#ff00ff','#ff99ff','#ffffff','#ff99ff']; glitches.forEach(g=>{ if(!g.fixed){ g.flicker=(g.flicker+1)|0; ctx.globalAlpha=0.7 + Math.sin(Date.now()/200)*0.3; if(g.id==='ball'){ const isTele = (g.state==='telegraph'); ctx.fillStyle='white'; ctx.beginPath(); ctx.arc(g.x+TILE_SIZE/2, g.y+TILE_SIZE/2, Math.max(__ARC_MIN__, TILE_SIZE/3), 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = isTele ? '#ff66ff' : colors[(g.flicker>>>3)%colors.length]; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(g.x+TILE_SIZE/2, g.y+TILE_SIZE/2, Math.max(__ARC_MIN__, TILE_SIZE/4), Math.PI*0.2, Math.PI*0.8); ctx.stroke(); ctx.beginPath(); ctx.arc(g.x+TILE_SIZE/2, g.y+TILE_SIZE/2, Math.max(__ARC_MIN__, TILE_SIZE/4), Math.PI*1.2, Math.PI*1.8); ctx.stroke(); } else { ctx.fillStyle = colors[(g.flicker>>>3)%colors.length]; ctx.fillRect(g.x, g.y, g.size, g.size); } ctx.globalAlpha=1; } }); }

    // Grid Fragments draw
    function drawGridFragment(g){ if(g.taken) return; const s = TILE_SIZE*0.42; ctx.save(); ctx.translate(g.x + TILE_SIZE/2, g.y + TILE_SIZE/2); ctx.rotate((performance.now()/900) % (Math.PI*2)); ctx.strokeStyle = 'rgba(0,255,255,0.85)'; ctx.lineWidth = 2; ctx.strokeRect(-s/2, -s/2, s, s); const o = s*0.35; ctx.beginPath(); ctx.moveTo(-s/2, -s/2); ctx.lineTo(-s/2+o, -s/2-o); ctx.moveTo(s/2, -s/2); ctx.lineTo(s/2+o, -s/2-o); ctx.moveTo(-s/2, s/2); ctx.lineTo(-s/2+o, s/2-o); ctx.moveTo(s/2, s/2); ctx.lineTo(s/2+o, s/2-o); ctx.stroke(); ctx.strokeRect(-s/2+o, -s/2-o, s, s); ctx.globalAlpha=0.8; ctx.lineWidth=1; for(let i=-2;i<=2;i++){ ctx.beginPath(); ctx.moveTo(-s/2, i*(s/5)); ctx.lineTo(s/2, i*(s/5)); ctx.stroke(); ctx.beginPath(); ctx.moveTo(i*(s/5), -s/2); ctx.lineTo(i*(s/5), s/2); ctx.stroke(); } ctx.restore(); }
    function drawGridFragments(){ gridFragments.forEach(g=> drawGridFragment(g)); }

    // ===== RAU: Apparition (state machine) =====
    const rau = {
      x: player.x + TILE_SIZE*4,
      y: player.y - TILE_SIZE*2,
      R: 45,
      state: 'hidden', // materializing | visible | dematerializing
      alpha: 0,
      t: 0,
      materializeMs: 900,
      dematerializeMs: 700,
      visibleMin: 1600,
      visibleMax: 3400,
      nextSpawnIn: 1400,
      flicker: 0,
      spokeThisLife: false,
      // look & line colors
      lineColor: '#333',
      fur: '#F9E7C6'
    };

    let rauEncounteredEver = false;
    let rauRosetsuRemarkDone = false;

    function spawnRauNearAnomaly(){
      // 70%: æœªãƒ’ãƒƒãƒˆã®ã‚¢ãƒãƒãƒªãƒ¼è¿‘å‚ã«ã€30%: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¿‘å‚ã«
      const active = anomalies.filter(a=>!a.hit);
      let bx = player.x, by = player.y;
      if(active.length>0 && Math.random()<0.7){
        const a = active[Math.floor(Math.random()*active.length)];
        const R = TILE_SIZE * (3 + Math.random()*4);
        const ang = Math.random()*Math.PI*2;
        bx = clamp(a.x + Math.cos(ang)*R, TILE_SIZE*2, world.w - TILE_SIZE*2);
        by = clamp(a.y + Math.sin(ang)*R, TILE_SIZE*2, world.h - TILE_SIZE*2);
      } else {
        const R = TILE_SIZE * (3 + Math.random()*3);
        const ang = Math.random()*Math.PI*2;
        bx = clamp(player.x + Math.cos(ang)*R, TILE_SIZE*2, world.w - TILE_SIZE*2);
        by = clamp(player.y + Math.sin(ang)*R, TILE_SIZE*2, world.h - TILE_SIZE*2);
      }
      rau.x = bx; rau.y = by; rau.t = 0; rau.spokeThisLife = false; rau.state = 'materializing';
    }

    function updateRau(dt){
      // spawn scheduler
      if(rau.state==='hidden'){
        rau.nextSpawnIn -= dt;
        if(rau.nextSpawnIn<=0){ spawnRauNearAnomaly(); rau.nextSpawnIn = 3200 + Math.random()*3200; }
      }

      rau.t += dt;
      if(rau.state==='materializing'){
        const k = clamp(rau.t/rau.materializeMs, 0, 1);
        rau.alpha = 1 - Math.pow(1-k,3);
        if(k>=1){ rau.state='visible'; rau.t = 0; }
      } else if(rau.state==='visible'){
  const ttl = rau.visibleMin + (rau.visibleMax-rau.visibleMin)*( (Math.sin(performance.now()/533)+1)/2 );
  const osc = 0.06 * Math.sin(performance.now()/240) + 0.04 * Math.sin(performance.now()/123);
  rau.alpha = clamp(0.85 + osc - 0.12*rau.flicker, 0, 1);
  if(rau.t>ttl){ rau.state='dematerializing'; rau.t=0; }

  // ãŸã¾ã«ã¡ã‚‰ã¤ã
  if(Math.random()<0.008){ rau.flicker = Math.max(rau.flicker, 1); }

  // ç”»é¢å†…ã«è¦‹ãˆã¦ã„ã‚‹ ã‚‚ã—ãã¯ 3ã‚¿ã‚¤ãƒ«ä»¥å†… ã«è¿‘ã¥ã„ãŸã‚‰ã€Œé­é‡ã€æ‰±ã„
  const d = dist(player.x+player.size/2, player.y+player.size/2, rau.x, rau.y);
  if (isOnScreen(rau.x, rau.y) || d < TILE_SIZE*3.0) {
    rauEncounteredEver = true;
  }

  // ãƒ©ã‚¦ã®ã²ã¨ã“ã¨ï¼ˆåŠå¾„ã‚’å°‘ã—åºƒã’ã‚‹ï¼‰
  if(!rau.spokeThisLife && d < TILE_SIZE*1.8){
    const lines = ['â€¦â€¦ãƒ­ã‚»ãƒ„ï¼Ÿ','å¯’ããªã„ï¼Ÿ','ã“ã“ã¯â€¦â€¦å¤¢ï¼Ÿ','ã‚ãŸã—ã€ã ã„ã˜ã‚‡ã†ã¶ã€‚'];
    showDialogue(lines[Math.floor(Math.random()*lines.length)], 1600, 'rau');
    rau.spokeThisLife = true;

}
      } else if(rau.state==='dematerializing'){
        const k = clamp(rau.t/rau.dematerializeMs, 0, 1);
        rau.alpha = 1 - k*k*k;
        if(k>=1){
          if(!rauRosetsuRemarkDone && rauEncounteredEver){
            showDialogue('ã‚ã®ä¸æ€è­°ãªå­ã¯èª°ï¼Ÿï¼Ÿå¤§ãã„ã—æ¶ˆãˆã¡ã‚ƒã£ãŸã€ã€ã€ã€', 3000, 'ãƒ­ã‚»ãƒ„');
            rauRosetsuRemarkDone = true;
          }
          rau.state='hidden'; rau.t=0; rau.alpha=0;
        }
      } else {
        rau.alpha = 0;
      }
      // flicker decay
      if(rau.flicker>0){ rau.flicker = Math.max(0, rau.flicker - dt/120); }
    }

    function drawRauGhost(){
      if(rau.alpha<=0) return;
      const a = clamp(rau.alpha, 0, 1);
      // å¾®æºã‚Œ
      const shake = rau.flicker>0 ? 2*rau.flicker : 0.6*((Math.sin(performance.now()/533)+1)/2);
      const jx = ( (Math.sin(performance.now()*0.0031) + Math.sin(performance.now()*0.0047) )*0.5 ) * shake;
      const jy = ( (Math.sin(performance.now()*0.0042) + Math.sin(performance.now()*0.0053) )*0.5 ) * shake;

      // ã†ã—ã‚ã®æ·¡ã„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
      ctx.save();
      ctx.globalAlpha = 0.15 * a;
      for(let i=0;i<7;i++){
        const rx = 36 + i*8, ry = 10 + i*3;
        ctx.beginPath(); ctx.ellipse(rau.x, rau.y + 150 + i*10, rx, ry, 0, 0, Math.PI*2); ctx.fillStyle = 'rgba(160,200,255,0.25)'; ctx.fill();
      }
      ctx.restore();

      // æœ¬ä½“ï¼ˆã‚¹ãƒšã‚¯ãƒˆãƒ©ãƒ«è¼ªéƒ­ + æœ¬æç”»ï¼‰
      const ghostMix = 0.65 + 0.35*a;
      ctx.save();
      ctx.globalAlpha = 0.25*a; drawRauFrontCore(rau.x + 0.3 + jx, rau.y + jy, 45, rau.fur, rau.lineColor, true);
      ctx.globalAlpha = 0.25*a; drawRauFrontCore(rau.x - 0.3 + jx, rau.y + jy, 45, rau.fur, rau.lineColor, true);
      ctx.globalAlpha = ghostMix; drawRauFrontCore(rau.x + jx, rau.y + jy, 45, rau.fur, rau.lineColor, false);

      // ãã‚‰ã‚ã
      ctx.globalAlpha = 0.25*a;
      for(let i=0;i<8;i++){
        const ang = Math.random()*Math.PI*2; const rr = 26 + Math.random()*36;
        ctx.beginPath(); ctx.arc(rau.x+Math.cos(ang)*rr, rau.y+Math.sin(ang)*rr, 1.2 + Math.random()*1.1, 0, Math.PI*2); ctx.fillStyle='rgba(180,255,245,.9)'; ctx.fill();
      }
      // ã‚¹ãƒ©ã‚¤ã‚¹ãƒ»ã‚°ãƒªãƒƒãƒ
      if(rau.flicker>0.1){
        const slices = 2 + Math.floor(rau.flicker*3);
        ctx.globalAlpha = 0.15 + 0.2*rau.flicker;
        for(let i=0;i<slices;i++){
          const wy = rau.y - 60 + Math.random()*120; const h = 2 + Math.random()*2; const dx = (Math.random()<0.5?-1:1) * (2 + Math.random()*6) * rau.flicker;
          ctx.fillStyle = 'rgba(0,255,255,0.35)'; ctx.fillRect(rau.x - 60 + dx, wy, 120, h);
        }
      }
      ctx.restore();
    }

    // Rau Core Drawing (Rosetsuæº–æ‹ )
    function drawRauFrontCore(x, y, R, fur, line, outlineOnly){
      const k = 0.70; // ear base on head circle
      const axL = x - R*k, ayL = y - R*k;
      const axR = x + R*k, ayR = y - R*k;
      const tipL = { x: x - R*0.95, y: y - R*1.10 };
      const tipR = { x: x + R*0.95, y: y - R*1.10 };
      const ixL = x - R*0.36, iyL = y - R*0.62;
      const ixR = x + R*0.36, iyR = y - R*0.62;

      if(!outlineOnly){ ctx.fillStyle = fur; }
      ctx.strokeStyle = line; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(x, y, Math.max(__ARC_MIN__, R), 0, Math.PI*2); if(!outlineOnly) ctx.fill(); ctx.stroke();

      if(!outlineOnly){ ctx.fillStyle = fur; }
      // left ear
      ctx.beginPath(); ctx.moveTo(axL, ayL); ctx.quadraticCurveTo(x - R*0.78, y - R*0.86, tipL.x, tipL.y); ctx.quadraticCurveTo(x - R*0.55, y - R*0.90, ixL, iyL); ctx.closePath(); if(!outlineOnly) ctx.fill(); ctx.stroke();
      // right ear
      ctx.beginPath(); ctx.moveTo(axR, ayR); ctx.quadraticCurveTo(x + R*0.78, y - R*0.86, tipR.x, tipR.y); ctx.quadraticCurveTo(x + R*0.55, y - R*0.90, ixR, iyR); ctx.closePath(); if(!outlineOnly) ctx.fill(); ctx.stroke();

      if(!outlineOnly){
        // eyes
        ctx.fillStyle = '#111'; circle(x - R*0.30, y - R*0.18, 6); circle(x + R*0.30, y - R*0.18, 6);
        ctx.fillStyle = '#fff'; circle(x - R*0.36, y - R*0.27, 2.4); circle(x + R*0.22, y - R*0.27, 2.4);
        // nose & mouth
        ctx.fillStyle = '#222'; circle(x, y - R*0.02, 4);
        ctx.beginPath(); ctx.arc(x, y + 12, 12, Math.PI*0.12, Math.PI*(1-0.12)); ctx.lineWidth = 2; ctx.strokeStyle = line; ctx.stroke();
        // body
        const gap = 6; const bodyRx = R * 0.78, bodyRy = R * 1.15; const bodyCy = y + R + gap + bodyRy;
        ctx.fillStyle = '#F5A7B8'; ctx.beginPath(); ctx.ellipse(x, bodyCy, bodyRx, bodyRy, 0, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = line; ctx.stroke();
        // paws & shadow
        ctx.fillStyle = fur; circle(x - R*0.32, bodyCy + bodyRy - 6, 8, true); circle(x + R*0.32, bodyCy + bodyRy - 6, 8, true);
        ctx.globalAlpha = 0.14; ellipse(x, bodyCy + bodyRy + 12, bodyRx*1.0, bodyRy*0.25, '#000'); ctx.globalAlpha = 1;
      }
      function circle(cx, cy, r, strokeToo){ ctx.beginPath(); ctx.arc(cx, cy, Math.max(__ARC_MIN__, r), 0, Math.PI*2); ctx.fill(); if(strokeToo){ ctx.strokeStyle = line; ctx.stroke(); } }
      function ellipse(cx, cy, rx, ry, fill){ ctx.beginPath(); ctx.ellipse(cx, cy, Math.max(__ARC_MIN__, rx), Math.max(__ARC_MIN__, ry), 0, 0, Math.PI*2); ctx.fillStyle = fill; ctx.fill(); }
    }

    // ===== Anomaly System (æœ¬å®Ÿè£…) =====
    function spawnAnomaly(){
      // ãƒãƒ©æœªå–å¾—ã®è¿‘å‚ã« 70% ã®ç¢ºç‡ã§å‡ºç¾ï¼æ®‹ã‚Šã¯ãƒ©ãƒ³ãƒ€ãƒ 
      const remaining = roses.filter(r=>!r.taken);
      const margin = TILE_SIZE*3; let x, y;
      if(remaining.length>0 && Math.random()<0.7){
        const r = remaining[Math.floor(Math.random()*remaining.length)];
        const R = TILE_SIZE * (4 + Math.random()*4);
        const ang = Math.random()*Math.PI*2;
        x = clamp(r.x + Math.cos(ang)*R, margin, world.w - margin);
        y = clamp(r.y + Math.sin(ang)*R, margin, world.h - margin);
      } else {
        x = Math.random()*(world.w - margin*2) + margin;
        y = Math.random()*(world.h - margin*2) + margin;
      }
      anomalies.push({ x, y, age:0, life:6000, maxR:TILE_SIZE*9, hit:false, rings:3 });
    }
    function updateAnomalies(dt){
      anomalyTimer -= dt;
      if(anomalyTimer<=0){ spawnAnomaly(); anomalyTimer = 3000 + Math.random()*3000; }
      for(let i=anomalies.length-1;i>=0;i--){ const a = anomalies[i]; a.age += dt; if(a.age > a.life) anomalies.splice(i,1); }
    }
    function drawAnomalies(){ ctx.save(); anomalies.forEach(a=>{ for(let i=0;i<a.rings;i++){ const phase = (a.age/a.life + i/a.rings) % 1; const r = Math.max(__ARC_MIN__, a.maxR * phase); const alpha = 0.75 * (1 - phase); ctx.beginPath(); ctx.arc(a.x, a.y, r, 0, Math.PI*2); ctx.strokeStyle = 'rgba(255,105,180,' + alpha + ')'; ctx.lineWidth = 4; ctx.stroke(); } const pulse = 1 + 0.25 * Math.sin(a.age/120); ctx.beginPath(); ctx.arc(a.x, a.y, Math.max(__ARC_MIN__, 6*pulse), 0, Math.PI*2); ctx.fillStyle = 'rgba(255,105,180,0.85)'; ctx.fill(); }); ctx.restore(); }

    // ===== Update =====
    function movePlayer(dx,dy){ const nx=player.x+dx, ny=player.y+dy; if(!isBlocked('player', nx, player.y, player.size)) player.x=nx; if(!isBlocked('player', player.x, ny, player.size)) player.y=ny; }
    function updatePlayer(){ player.isMoving=false; let dx=0, dy=0; const now=performance.now(); if(now < inputLockedUntil){ return; } if(keys.ArrowUp) dy -= player.speed; if(keys.ArrowDown) dy += player.speed; if(keys.ArrowLeft) dx -= player.speed; if(keys.ArrowRight) dx += player.speed; if(touch.active){ const cx = player.x + player.size/2, cy = player.y + player.size/2; const vx = touch.wx - cx, vy = touch.wy - cy; const d = Math.hypot(vx, vy); if(d > 6){ dx = (vx/d) * player.speed; dy = (vy/d) * player.speed; } } if(dx||dy) player.isMoving=true; movePlayer(dx, dy); }

    function updateNPCs(dt){ npcs.forEach(n=>{ n.wander -= dt; if(n.wander<=0){ const ang=Math.random()*Math.PI*2; n.vx=Math.cos(ang)*n.speed; n.vy=Math.sin(ang)*n.speed; n.wander = 1200+Math.random()*1800; } const dxh=n.homeX-n.x, dyh=n.homeY-n.y, d=Math.hypot(dxh,dyh); if(d>n.radius){ const ang=Math.atan2(dyh,dxh); n.vx=Math.cos(ang)*n.speed; n.vy=Math.sin(ang)*n.speed; } const nx=n.x+n.vx, ny=n.y+n.vy; if(!isBlocked('npc', nx, n.y, n.size)) n.x=nx; else n.vx*=-0.6; if(!isBlocked('npc', n.x, ny, n.size)) n.y=ny; else n.vy*=-0.6; }); }

    // ãƒœãƒ¼ãƒ«è¿‘æ¥ã‚¹ãƒãƒ¼ãƒ³â†’ãƒ†ãƒ¬ã‚°ãƒ©ãƒ•â†’é€ƒèµ°
    function spawnBallNearPlayer(){ const ball = glitches.find(g=>g.id==='ball'); if(!ball) return; const R = TILE_SIZE*5; let ang = Math.random()*Math.PI*2; const bx = clamp(player.x + Math.cos(ang)*R, TILE_SIZE, world.w - TILE_SIZE*2); const by = clamp(player.y + Math.sin(ang)*R, TILE_SIZE, world.h - TILE_SIZE*2); ball.x=bx; ball.y=by; ball.size=TILE_SIZE; ball.state='telegraph'; ball.timer=900; ball.immune=900; ball.vx=0; ball.vy=0; ball.fixed=false; showDialogue('ï¼Ÿï¼Ÿï¼Ÿ: ãªã«ã‹ãŒç¾ã‚ŒãŸâ€¦', 1200, 'ã‚·ã‚¹ãƒ†ãƒ '); }
    function updateBall(dt){ const ball = glitches.find(g=>g.id==='ball'); if(!ball || ball.fixed) return; if(ball.state==='idle') return; if(ball.state==='telegraph'){ ball.timer -= dt; if(ball.timer<=0){ const ang=Math.atan2(ball.y-player.y, ball.x-player.x); const spd=2.8; ball.vx=Math.cos(ang)*spd; ball.vy=Math.sin(ang)*spd; ball.state='run'; ball.timer=1800; showDialogue('ãƒœãƒ¼ãƒ«: ãƒ”ã‚³ãƒƒï¼', 900, 'ã‚·ã‚¹ãƒ†ãƒ '); } return; } if(ball.state==='run'){ const speed=Math.hypot(ball.vx,ball.vy), maxSpd=4.2, acc=0.002*dt; const ns=Math.min(maxSpd, speed+acc); if(speed>0){ ball.vx*=ns/speed; ball.vy*=ns/speed; } ball.x+=ball.vx; ball.y+=ball.vy; if(ball.x<TILE_SIZE||ball.x>world.w-ball.size-TILE_SIZE) ball.vx*=-1; if(ball.y<TILE_SIZE||ball.y>world.h-ball.size-TILE_SIZE) ball.vy*=-1; } if(ball.immune>0) ball.immune-=dt; const d=dist(player.x+player.size/2, player.y+player.size/2, ball.x+ball.size/2, ball.y+ball.size/2); if(ball.immune<=0 && d < player.size/2 + (ball.size/3)){ ball.fixed=true; ball.state='idle'; handleGlitchFix('ball'); } }

    function updateGlitches(){ glitches.forEach(g=>{ if(g.id==='normal' && !g.fixed){ const d=dist(player.x+player.size/2, player.y+player.size/2, g.x+TILE_SIZE/2, g.y+TILE_SIZE/2); if(d<TILE_SIZE){ g.fixed=true; handleGlitchFix('normal'); } } }); }

    // Roses update
    function updateRoses(){ for(const r of roses){ if(r.taken) continue; const d = dist(player.x+player.size/2, player.y+player.size/2, r.x+TILE_SIZE/2, r.y+TILE_SIZE/2); if(d < TILE_SIZE*0.7){ r.taken = true; roseCount++; triggerWhiteBurst(r.x+TILE_SIZE/2, r.y+TILE_SIZE/2); showDialogue(`è‰²ã®ãªã„ãƒãƒ©ã‚’æ‰‹ã«å…¥ã‚ŒãŸ (${roseCount}/${ROSE_TARGET})`, 1200, 'ã‚·ã‚¹ãƒ†ãƒ '); if(roseCount >= ROSE_TARGET){ if(!sixBitPlayed) { triggerBinarySequence(); } else { triggerRevelation(); } } } } }

    // Grid Fragments update
    function updateGridFragments(){ for(const g of gridFragments){ if(g.taken) continue; const d = dist(player.x+player.size/2, player.y+player.size/2, g.x+TILE_SIZE/2, g.y+TILE_SIZE/2); if(d < TILE_SIZE*0.7){ g.taken = true; gridCount++; triggerGridShimmer(); showDialogue(`æ ¼å­ç‰‡ã‚’æ‰‹ã«å…¥ã‚ŒãŸ (${gridCount}/${GRID_TARGET})`, 1200, 'ã‚·ã‚¹ãƒ†ãƒ '); if(gridCount >= GRID_TARGET){ triggerMegaGrid(); } } } }

    function triggerGridShimmer(){ gridFX.t = gridFX.dur; }
    function drawGridFX(dt){ if(gridFX.t<=0) return; gridFX.t -= dt; gridFX.phase += dt*0.002; ctx.save(); ctx.setTransform(1,0,0,1,0,0); ctx.globalAlpha = 0.12 + 0.18*(gridFX.t/gridFX.dur); for(let y=0;y<canvas.height;y+=3){ ctx.fillStyle='rgba(0,255,255,0.08)'; ctx.fillRect(0,y,canvas.width,1); } ctx.globalAlpha = 0.18 + 0.25*(gridFX.t/gridFX.dur); ctx.strokeStyle = 'rgba(0,255,255,0.6)'; ctx.lineWidth = 1; const step = 22, off = (gridFX.phase*40)%step; for(let x=-canvas.height; x<canvas.width+canvas.height; x+=step){ ctx.beginPath(); ctx.moveTo(x+off, 0); ctx.lineTo(x+off-canvas.height, canvas.height); ctx.stroke(); } ctx.restore(); }

    function triggerMegaGrid(){ revelation.t = Math.max(revelation.t, revelation.dur*1.5); desaturatePalette = 1; showDialogue('æ ¼å­ãŒéœ‡ãˆã¦ã„ã‚‹â€¦æ§‹é€ ãŒéœ²å‡ºã—ãŸï¼', 2200, 'ãƒ­ã‚»ãƒ„'); }

    // ===== 6-bit Binary Sequence =====
    function triggerBinarySequence(debug=false){ if(sixBitPlayed && !debug) return; sixBitPlayed = true; const approxDuration = 2200; inputLockedUntil = performance.now() + approxDuration; binaryOverlay.style.display = 'flex'; let val = 1; const max = 63; const baseTick = 50; function step(){ const bin = val.toString(2).padStart(6,'0'); binaryText.textContent = (Math.random()<0.12) ? bin.replace(/[01]/g,()=> (Math.random()>.5?'1':'0')) : bin; const nextTick = Math.max(18, baseTick - val*0.4); val++; if(val<=max){ setTimeout(step, nextTick); } else { setTimeout(()=>{ binaryOverlay.style.display = 'none'; triggerRevelation(); }, 120); } } step(); }

    // ===== Revelation =====
    function triggerRevelation(){ revelation.t = revelation.dur; desaturatePalette = 1; showDialogue('ã“ã“ã¯â€¦æ ¼å­â€¦ï¼Ÿä¸–ç•Œã®éª¨çµ„ã¿ãŒè¦‹ãˆã‚‹â€¦', 2400, 'ãƒ­ã‚»ãƒ„'); }
    function updateRevelation(dt){ if(revelation.t>0){ revelation.t -= dt; desaturatePalette = Math.max(0, revelation.t / revelation.dur); } }
    function drawRevelationOverlay(){ if(revelation.t<=0) return; ctx.save(); ctx.setTransform(1,0,0,1,0,0); const a=0.15+0.15*(revelation.t/revelation.dur); ctx.globalAlpha=a; for(let y=0;y<canvas.height;y+=3){ ctx.fillStyle='rgba(255,255,255,0.06)'; ctx.fillRect(0,y,canvas.width,1);} ctx.restore(); ctx.save(); ctx.setTransform(camera.dpr,0,0,camera.dpr,0,0); ctx.translate(-camera.x,-camera.y); ctx.globalAlpha=0.25+0.35*(revelation.t/revelation.dur); ctx.strokeStyle='#00ffff'; ctx.lineWidth=1; for(let x=0;x<=world.w;x+=TILE_SIZE){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,world.h); ctx.stroke(); } for(let y=0;y<=world.h;y+=TILE_SIZE){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(world.w,y); ctx.stroke(); } ctx.restore(); }
    function drawDesaturateVeil(){ if(desaturatePalette<=0) return; ctx.save(); ctx.setTransform(1,0,0,1,0,0); ctx.globalAlpha = 0.25 * desaturatePalette; ctx.fillStyle = '#cfcfcf'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.restore(); }

    // ===== HUD =====
    function drawHUD(){ ctx.save(); ctx.setTransform(camera.dpr,0,0,camera.dpr,0,0); const pad=10; const w=260; const h=34; const x=canvas.width/camera.dpr-w-pad; const y=8+pad; ctx.fillStyle='rgba(0,0,0,0.55)'; ctx.fillRect(x,y,w,h); ctx.strokeStyle='rgba(255,255,255,0.6)'; ctx.strokeRect(x+0.5,y+0.5,w-1,h-1); ctx.fillStyle='#fff'; ctx.font='bold 16px system-ui, sans-serif'; ctx.fillText('ğŸŒ¹ ' + roseCount + '/' + ROSE_TARGET, x+10, y+22); ctx.fillText('â–¦ ' + gridCount + '/' + GRID_TARGET, x+120, y+22); ctx.restore(); }

    // ===== Interact / Quest =====
    function interact(){ let acted=false; npcs.forEach(n=>{ const d=dist(player.x+player.size/2, player.y+player.size/2, n.x+TILE_SIZE/2, n.y+TILE_SIZE/2); if(d<TILE_SIZE*1.2){ if(n.id==='tetsuji' && !tetsujiQuestAccepted){ tetsujiQuestAccepted=true; showDialogue(n.dialogue, 2600, 'tetsuji'); setTimeout(()=>{ showDialogue('å¤§å¤‰ã ï¼ã‚ã®ãƒœãƒ¼ãƒ«ã€ã™ã”ã„å‹¢ã„ã§å‹•ãå‡ºã—ãŸãï¼', 2400, 'ãƒ­ã‚»ãƒ„'); }, 2700); setTimeout(()=>{ spawnBallNearPlayer(); }, 1600); } else { showDialogue(n.dialogue, 3200, n.id); } acted=true; } }); if(!acted) showDialogue('ã‚¯ãƒ³ã‚¯ãƒ³â€¦ç‰¹ã«ä½•ã‚‚ãªã„ã¿ãŸã„ã ã€‚', 1800, 'ãƒ­ã‚»ãƒ„'); }

    function handleGlitchFix(id){ if(id==='ball'){ showDialogue('ã“ã®é‡çƒãƒœãƒ¼ãƒ«â€¦é‰„äºŒãã‚“ã®ã ï¼è¿”ã—ã¦ã‚ã’ãªãã‚ƒï¼', 2600, 'ãƒ­ã‚»ãƒ„'); const t=npcs.find(n=>n.id==='tetsuji'); if(t) t.dialogue='ã‚ãƒ¼ï¼åƒ•ã®ãƒœãƒ¼ãƒ«ã ï¼ã‚ã‚ŠãŒã¨ã†ã€ãƒ­ã‚»ã¡ã‚ƒã‚“ï¼å›ã¯ãƒ’ãƒ¼ãƒ­ãƒ¼ã ã­ï¼'; } else { showDialogue('ã‚ˆã—ã€ä¸–ç•Œã®ãƒã‚°ã‚’ç›´ã—ãŸï¼', 2200, 'ãƒ­ã‚»ãƒ„'); } checkWin(); }
    function checkWin(){
      const allFixed = glitches.filter(g=>g.id!=='ball').every(g=>g.fixed) && (glitches.find(g=>g.id==='ball')?.fixed);
      if(allFixed) showDialogue('ã‚„ã£ãŸï¼å…¨éƒ¨ã®ãƒã‚°ã‚’ç›´ã—ãŸãï¼ã“ã‚Œã§ã¿ã‚“ãªå®‰å¿ƒã ï¼', 4800, 'ãƒ­ã‚»ãƒ„', true);
    }

    // ===== Loop =====
    function frameBegin(){ ctx.save(); ctx.setTransform(camera.dpr,0,0,camera.dpr,0,0); ctx.clearRect(0,0,canvas.width,canvas.height); ctx.translate(-camera.x,-camera.y); }
    function drawTouchIndicator(){ if(!touch.active) return; ctx.save(); ctx.strokeStyle='rgba(0,0,0,0.35)'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(touch.wx, touch.wy, Math.max(__ARC_MIN__, 12), 0, Math.PI*2); ctx.stroke(); ctx.restore(); }
    function frameEnd(){ ctx.restore(); }
    let last = performance.now();
    function gameLoop(now){
      const dt=Math.min(50, now-last); last=now;
      const timeScale = revelation.t>0 ? revelation.slow : 1;
      const sdt = dt * timeScale;
      updatePlayer();
      updateNPCs(sdt);
      if(tetsujiQuestAccepted) updateBall(sdt);
      updateGlitches();
      updateAnomalies(sdt);
      updateRoses();
      updateGridFragments();
      updateRevelation(sdt);
      updateBursts(sdt);
      updateRau(sdt);

      clampCamera(player.x+player.size/2, player.y+player.size/2);
      frameBegin();
      drawMap();
      drawNPCs();
      drawGlitches();
      drawAnomalies();
      drawRoses();
      drawGridFragments();
      drawRosetsu(player);
      drawRauGhost();
      drawTouchIndicator();
      drawHUD();
      frameEnd();
      drawDesaturateVeil();
      drawFlashOverlay(sdt);
      drawRevelationOverlay();
      drawBursts();
      drawGridFX(dt);
      requestAnimationFrame(gameLoop);
    }

    function startGame(){
      setupControls();
      showDialogue('ã‚²ãƒ¼ãƒ ç”»é¢ã‚’ã‚¿ãƒƒãƒ—ã—ã¦ã‚¹ã‚¿ãƒ¼ãƒˆï¼', 2500, 'ã‚·ã‚¹ãƒ†ãƒ ');
      clampCamera(player.x, player.y);
      // æœ€åˆã®ã‚¢ãƒãƒãƒªãƒ¼ã‚’ç¢ºå®Ÿã«å‡ºã™
      spawnAnomaly(); anomalyTimer = 2500 + Math.random()*1000;
      requestAnimationFrame(gameLoop);
    }

    // ===== Pink Universe (Flash) =====
    function triggerFlash(force=false){
      if(pinkSeen && !force) return;
      pinkSeen = true; flash.dur = 1200; flash.t = flash.dur;
      inputLockedUntil = performance.now() + flash.dur + 40;
      const area = canvas.width * canvas.height;
      const count = Math.max(80, Math.min(220, Math.floor(area / 8000)));
      flash.stars = Array.from({length: count}, () => ({
        x: Math.random()*canvas.width,
        y: Math.random()*canvas.height,
        r: 0.6 + Math.random()*1.8,
        tw: Math.random()*Math.PI*2
      }));
      flash.cb = () => { showDialogue('ä»Šã®ã¯ã€ã€ã€å®‡å®™ã«è¦‹ãˆãŸã€ã€ã€ãƒ”ãƒ³ã‚¯ã®ç©ºã«æ˜Ÿã€‚ãªã‚“ãªã‚“ã ã€ã€ã€ã€ã¾ã¼ã‚ã—ï¼Ÿï¼Ÿ', 3200, 'ãƒ­ã‚»ãƒ„'); };
    }
    function drawFlashOverlay(dt){
      if(flash.t<=0) return;
      flash.t -= dt; const k = Math.max(0, flash.t/flash.dur);
      ctx.save(); ctx.setTransform(1,0,0,1,0,0);
      ctx.globalAlpha = 0.92; ctx.fillStyle = '#ff0099';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      const tnow = performance.now(); ctx.globalAlpha = 1.0;
      for(const s of flash.stars){
        const tw = 0.6 + 0.4*Math.sin(tnow/200 + s.tw);
        const y  = s.y - (1.2 * (1-k));
        ctx.beginPath(); ctx.arc(s.x, y, Math.max(__ARC_MIN__, s.r*tw), 0, Math.PI*2);
        ctx.fillStyle = (s.tw % 1 > 0.5) ? 'rgba(255,255,255,0.9)' : 'rgba(255,180,220,0.95)';
        ctx.fill();
      }
      ctx.restore();
      if(flash.t<=0 && typeof flash.cb === 'function'){ const cb = flash.cb; flash.cb = null; cb(); }
    }

    // ===== Boot =====
    window.addEventListener('resize', layoutCanvas);
    // èµ·å‹•æ™‚ã¯ã‚­ãƒ£ãƒ³ãƒã‚¹ã ã‘æ•´ãˆã¦ã‚²ãƒ¼ãƒ ã¯é–‹å§‹ã—ãªã„ï¼ˆã‚ªãƒ¼ãƒ—ãƒ‹ãƒ³ã‚°çµ‚äº†ã§é–‹å§‹ï¼‰
    window.addEventListener('load', () => { layoutCanvas(); });
    document.fonts && document.fonts.ready && document.fonts.ready.then(layoutCanvas);

    // ===== Minimal tests (enable via ?test=1) =====
    try {
      const params = new URLSearchParams(location.search);
      if (params.get('test') === '1') {
        console.info('[TEST] Running smoke testsâ€¦');
        // 1) spawnAnomaly å®šç¾©&æŒ™å‹•
        console.assert(typeof spawnAnomaly === 'function', 'spawnAnomaly should be defined');
        const before = anomalies.length; spawnAnomaly();
        console.assert(anomalies.length === before + 1, 'spawnAnomaly should push one anomaly');
        // 2) updateAnomalies ã§å¯¿å‘½ç®¡ç†
        const a0 = anomalies[anomalies.length-1]; const oldAge = a0.age; updateAnomalies(100); console.assert(anomalies[anomalies.length-1].age >= oldAge, 'anomaly age should advance');
        // 3) drawAnomalies ã¯ä¾‹å¤–ã‚’æŠ•ã’ãªã„
        try { drawAnomalies(); console.info('[TEST] drawAnomalies rendered OK'); } catch(e){ console.error('[TEST] drawAnomalies threw', e); }
        // 4) ãƒ”ãƒ³ã‚¯å®‡å®™æ¼”å‡º
        triggerFlash(true);
        console.assert(pinkSeen === true, 'triggerFlash should set pinkSeen');
        // 5) Binary sequence ä¸€åº¦ã ã‘
        const prevSix = sixBitPlayed; triggerBinarySequence(true); console.assert(sixBitPlayed === true, 'binary sequence should mark played');
        // 6) arc/ellipse radius guard
        try {
          ctx.beginPath();
          ctx.arc(10, 10, -5, 0, Math.PI*2);
          ctx.arc(20, 10, 0, 0, Math.PI*2);
          ctx.stroke();
          console.info('[TEST] arc radius guard OK');
        } catch (e) {
          console.error('[TEST] arc radius guard FAILED', e);
        }
        try {
          ctx.beginPath();
          ctx.ellipse(30, 10, -2, 0, 0, 0, Math.PI*2);
          ctx.stroke();
          console.info('[TEST] ellipse radius guard OK');
        } catch (e) {
          console.error('[TEST] ellipse radius guard FAILED', e);
        }
        // 7) Rau ãƒ­ã‚»ãƒ„ã®å°è©ãŒä¸€åº¦ã ã‘
        try {
          let __origShow = showDialogue, __count = 0;
          showDialogue = function(){ __count++; return __origShow.apply(this, arguments); };
          rauRosetsuRemarkDone = false; rauEncounteredEver = true;
          rau.state='dematerializing'; rau.t = rau.dematerializeMs; updateRau(16);
          const firstCount = __count;
          // ã‚‚ã†ä¸€åº¦åŒã˜æ¡ä»¶ã‚’æµã—ã¦ã‚‚å¢—ãˆãªã„
          rau.state='dematerializing'; rau.t = rau.dematerializeMs; updateRau(16);
          console.assert(__count === firstCount, 'Rosetsu remark should fire exactly once');
          showDialogue = __origShow;
          console.info('[TEST] Rau Rosetsu remark once OK');
        } catch(e){ console.error('[TEST] Rau Rosetsu remark test FAILED', e); }
        console.info('[TEST] All assertions completed');
      }
    } catch(e) { console.warn('[TEST] Error while running tests', e); }
  </script>
</body>
</html>
