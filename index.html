<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Rosetsu and the Simulated World — Wide Stage</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700&family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet" />
  <style>
    body { font-family: 'Noto Sans JP', sans-serif; background:#000; margin:0; }
    /* Opening */
    #openingSequence { position: relative; width: 100vw; height: 100vh; overflow: hidden; }
    .stars { position:absolute; inset:0; background:transparent; }
    .stars-small { background-image: radial-gradient(1px 1px at 20px 30px, #eee, rgba(0,0,0,0)), radial-gradient(1px 1px at 40px 70px, #fff, rgba(0,0,0,0)), radial-gradient(1px 1px at 50px 160px, #ddd, rgba(0,0,0,0)), radial-gradient(1px 1px at 90px 40px, #fff, rgba(0,0,0,0)), radial-gradient(1px 1px at 130px 80px, #fff, rgba(0,0,0,0)), radial-gradient(1px 1px at 160px 120px, #ddd, rgba(0,0,0,0)); background-size: 200px 200px; animation: zoom 25s infinite; }
    .stars-medium { background-image: radial-gradient(2px 2px at 50px 50px, #fff, rgba(0,0,0,0)), radial-gradient(2px 2px at 100px 100px, #ddd, rgba(0,0,0,0)), radial-gradient(2px 2px at 200px 150px, #fff, rgba(0,0,0,0)); background-size: 300px 300px; animation: zoom 40s infinite; }
    @keyframes zoom { 0% { transform: scale(1);} 50% { transform: scale(1.2);} 100% { transform: scale(1);} }
    .perspective-container { position:absolute; inset:0; perspective: 400px; perspective-origin: 50% 60%; }
    .crawl-container { position:absolute; top:100%; width:80%; max-width:800px; left:50%; transform:translateX(-50%); transform-origin:50% 100%; animation:crawl 50s linear forwards; }
    .crawl-content { color:#feda4a; font-size:5.5vw; line-height:1.4; text-align:justify; font-weight:bold; transform: rotateX(20deg); }
    .crawl-episode-title { text-align:center; font-size:6vw; margin-bottom:2em; line-height:1.2; }
    @media (min-width:768px){ .crawl-content{font-size:42px;} .crawl-episode-title{font-size:48px;} }
    @keyframes crawl { from{top:100%;} to{top:-200%;} }
    .game-title-opening { position:absolute; top:50%; left:50%; color:#feda4a; font-weight:bold; text-align:center; opacity:0; transform: translate(-50%,-50%) scale(1.5); animation:titleZoom 7s forwards; }
    .main-title { font-size:10vw; white-space:nowrap; }
    @media (min-width:768px){ .main-title{font-size:72px;} }
    @keyframes titleZoom { 0%{opacity:1; transform: translate(-50%,-50%) scale(1.5);} 80%{opacity:1;} 100%{opacity:0; transform: translate(-50%,-50%) scale(0.1);} }
    .initial-text { position:absolute; top:50%; left:5%; transform:translateY(-50%); color:#49dafd; font-size:7vw; font-weight:bold; text-align:left; opacity:0; animation:initialFade 5s forwards; }
    @media (min-width:768px){ .initial-text{font-size:3em;} }
    @keyframes initialFade { 0%{opacity:0;} 20%{opacity:1;} 80%{opacity:1;} 100%{opacity:0;} }

    /* Game */
    .game-body { background:#f0f0f0; }
    #gameCanvas { display:block; background:#eaeaea; border:2px solid #333; border-radius:8px; box-shadow:0 4px 6px rgba(0,0,0,.1); image-rendering: pixelated; width:100%; height:auto; }
    .control-btn { transition: all .1s ease-in-out; user-select:none; }
    .control-btn:active { transform: scale(.92); }
    .dialogue-box { animation: slide-up .35s ease-out forwards; }
    @keyframes slide-up { from{ transform: translateY(100%); opacity:0;} to{ transform: translateY(0); opacity:1;} }
    /* iPhoneのセーフエリア対応 */
    :root { --safe-bottom: env(safe-area-inset-bottom); }
    #controls { padding-bottom: calc(var(--safe-bottom,0) + .25rem); }
  </style>
</head>
<body>
  <!-- Opening -->
  <div id="openingSequence">
    <div id="starsContainer" style="display:none;">
      <div class="stars stars-small"></div>
      <div class="stars stars-medium"></div>
    </div>
    <div id="initialText" class="initial-text">
      <p>遠い昔　　はるかかなたの</p>
      <p>銀河系で・・・</p>
    </div>
    <div id="gameTitleOpening" class="game-title-opening" style="display:none;">
      <p class="main-title">Rosetsu and the Simulated World</p>
    </div>
    <div id="perspectiveContainer" class="perspective-container" style="display:none;">
      <div id="crawlContainer" class="crawl-container">
        <div class="crawl-content">
          <h3 class="crawl-episode-title">エピソード４<br>新たなる覚醒</h3>
          <p>宇宙は、見えざる手によって編まれた精巧な幻影だった。</p>
          <p>&nbsp;</p>
          <p>無数の星々が輝く銀河の彼方で、その幻影は今、綻び始めている。</p>
          <p>&nbsp;</p>
          <p>それは小さな異変から始まった。食べても減らぬドッグフード、聞こえるはずのない電子音、そして姿を変える街の景色。</p>
          <p>&nbsp;</p>
          <p>白きチワワ、ロセツ。彼の鋭敏な嗅覚と聴覚は、人類が決して感知できぬ世界の“バグ”を捉えた。</p>
          <p>&nbsp;</p>
          <p>綻びは拡大し、やがて全ての記憶と存在をデータの彼方へと押し流すだろう。その運命を阻む者は、ただ一匹——。</p>
          <p>&nbsp;</p>
          <p>鯨岡家を守るため、そして真実を明らかにするため、ロセツは未知なる宇宙の深層へと旅立つ。彼の冒険は、シミュレーションの境界線を越え、世界の設計図そのものに迫ることとなる。</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Game -->
  <div id="mainGame" style="display:none;" class="flex flex-col items-center justify-center min-h-screen p-4">
    <div id="game-container" class="w-full max-w-2xl mx-auto">
      <h1 class="text-xl sm:text-2xl font-bold text-center text-gray-800 mb-3">Rosetsu and the Simulated World</h1>
      <canvas id="gameCanvas"></canvas>
    </div>
    <div id="dialogue-container" class="fixed bottom-24 left-0 right-0 p-3 flex justify-center z-10 pointer-events-none"></div>
    <div id="controls" class="fixed bottom-0 left-0 right-0 grid grid-cols-3 gap-2 w-full max-w-sm mx-auto p-3 z-20">
      <div></div>
      <button id="btn-up" class="control-btn bg-gray-700 text-white p-4 rounded-2xl shadow-md">↑</button>
      <div></div>
      <button id="btn-left" class="control-btn bg-gray-700 text-white p-4 rounded-2xl shadow-md">←</button>
      <button id="btn-down" class="control-btn bg-gray-700 text-white p-4 rounded-2xl shadow-md">↓</button>
      <button id="btn-right" class="control-btn bg-gray-700 text-white p-4 rounded-2xl shadow-md">→</button>
      <button id="btn-action" class="control-btn bg-lime-500 text-white p-4 rounded-2xl shadow-md col-span-3">TALK / CHECK</button>
    </div>
  </div>

  <script type="module">
    // ===== Layout helpers (for iPhone) =====
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const controlsEl = document.getElementById('controls');
    const dialogueEl = document.getElementById('dialogue-container');

    function layoutCanvas() {
      // Available height = viewport - controls - margins
      const rect = controlsEl.getBoundingClientRect();
      const controlsHeight = Math.max(rect.height, 160);
      const desiredHeight = Math.max(260, window.innerHeight - controlsHeight - 120);
      const desiredWidth = Math.min(window.innerWidth, 820); // keep text readable on iPhone
      const dpr = Math.min(window.devicePixelRatio || 1, 2); // cap DPR for perf

      canvas.style.width = desiredWidth + 'px';
      canvas.style.height = desiredHeight + 'px';
      canvas.width = Math.floor(desiredWidth * dpr);
      canvas.height = Math.floor(desiredHeight * dpr);

      camera.w = desiredWidth; // logical size (pre-scale)
      camera.h = desiredHeight;
      camera.dpr = dpr;
    }

    // ===== Opening sequence wiring =====
    const openingSequence = document.getElementById('openingSequence');
    const initialText = document.getElementById('initialText');
    const gameTitleOpening = document.getElementById('gameTitleOpening');
    const perspectiveContainer = document.getElementById('perspectiveContainer');
    const crawlContainer = document.getElementById('crawlContainer');
    const mainGame = document.getElementById('mainGame');
    const starsContainer = document.getElementById('starsContainer');

    let openingSkipped = false;
    const skipOpening = () => {
      if (openingSkipped) return;
      openingSkipped = true;
      openingSequence.style.display = 'none';
      document.body.classList.add('game-body');
      mainGame.style.display = 'flex';
      layoutCanvas();
      startGame();
    };

    openingSequence.addEventListener('click', skipOpening);
    openingSequence.addEventListener('touchstart', skipOpening);
    initialText.addEventListener('animationend', () => { if (openingSkipped) return; initialText.style.display = 'none'; starsContainer.style.display='block'; gameTitleOpening.style.display='block'; });
    gameTitleOpening.addEventListener('animationend', () => { if (openingSkipped) return; gameTitleOpening.style.display='none'; perspectiveContainer.style.display='block'; });
    crawlContainer.addEventListener('animationend', () => { if (openingSkipped) return; skipOpening(); });

    // ===== World / Camera =====
    const TILE_SIZE = 48; // visible tile size (logical)
    const WORLD_COLS = 60; // WIDE STAGE
    const WORLD_ROWS = 40;

    // Generate a world with borders and some obstacles
    const map = Array.from({ length: WORLD_ROWS }, (_, y) => (
      Array.from({ length: WORLD_COLS }, (_, x) => {
        if (y === 0 || y === WORLD_ROWS-1 || x === 0 || x === WORLD_COLS-1) return 1; // wall
        return 0; // grass
      })
    ));

    // add some patches of trees(3) and bush(4) as soft walls
    function addBlock(x, y, w, h, id){ for(let j=0;j<h;j++){ for(let i=0;i<w;i++){ map[y+j][x+i]=id; }}}
    addBlock(8, 6, 6, 3, 3); addBlock(16, 12, 4, 7, 4); addBlock(27, 9, 5, 5, 3);
    addBlock(40, 20, 8, 4, 4); addBlock(45, 30, 5, 5, 3); addBlock(12, 28, 7, 4, 4);

    // NPC(5,6) & glitches(7=normal,8=ball)
    const entities = {
      npcs: [
        {tile:[10, 10], id:'komaru', type:5, dialogue:'ロセちゃん。この世界のバグは、タフガイならすぐに見つけられるはず！'},
        {tile:[50, 28], id:'tetsuji', type:6, dialogue:'うぅ…首輪についてたももちゃんにもらった大事な野球ボールが、変な光と共になくなっちゃったんだ…'}
      ],
      glitches: [
        {tile:[25, 8], id:'normal', fixed:false, size:TILE_SIZE},
        {tile:[33, 18], id:'normal', fixed:false, size:TILE_SIZE},
        {tile:[44, 26], id:'ball', fixed:false, size:TILE_SIZE, vx:0, vy:0, flicker:0}
      ]
    };

    entities.npcs.forEach(n=>{ const [tx,ty]=n.tile; map[ty][tx]=n.type; });

    const world = { w: WORLD_COLS * TILE_SIZE, h: WORLD_ROWS * TILE_SIZE };

    const camera = { x: 0, y: 0, w: 0, h: 0, dpr: 1 };
    function clampCameraToPlayer(px, py){
      const marginX = camera.w * 0.35; // keep player off-center for better lookahead
      const marginY = camera.h * 0.35;
      let targetX = px - camera.w/2; let targetY = py - camera.h/2;
      // dead-zone smoothing
      if (px < camera.x + marginX) targetX = px - marginX;
      if (px > camera.x + camera.w - marginX) targetX = px + marginX - camera.w;
      if (py < camera.y + marginY) targetY = py - marginY;
      if (py > camera.y + camera.h - marginY) targetY = py + marginY - camera.h;
      camera.x = Math.max(0, Math.min(world.w - camera.w, targetX));
      camera.y = Math.max(0, Math.min(world.h - camera.h, targetY));
    }

    // ===== Player/State =====
    const player = { x: TILE_SIZE * 2, y: TILE_SIZE * (WORLD_ROWS-3), size: TILE_SIZE * 0.9, speed: 4.2, isMoving:false };
    const keys = {};
    let gameStarted = false; let tetsujiQuestAccepted = false; let dialogueTimeout;

    const npcs = entities.npcs.map(n=>({ x:n.tile[0]*TILE_SIZE, y:n.tile[1]*TILE_SIZE, ...n }));
    const glitches = entities.glitches.map(g=>({ x:g.tile[0]*TILE_SIZE, y:g.tile[1]*TILE_SIZE, ...g }));

    // ===== Drawing (with camera) =====
    function beginFrame(){ ctx.save(); ctx.setTransform(camera.dpr,0,0,camera.dpr,0,0); ctx.clearRect(0,0,canvas.width,canvas.height); ctx.translate(-camera.x, -camera.y); }
    function endFrame(){ ctx.restore(); }

    function drawMap(){
      const startCol = Math.max(0, Math.floor(camera.x / TILE_SIZE)-1);
      const endCol = Math.min(WORLD_COLS-1, Math.ceil((camera.x + camera.w) / TILE_SIZE)+1);
      const startRow = Math.max(0, Math.floor(camera.y / TILE_SIZE)-1);
      const endRow = Math.min(WORLD_ROWS-1, Math.ceil((camera.y + camera.h) / TILE_SIZE)+1);
      for(let y=startRow; y<=endRow; y++){
        for(let x=startCol; x<=endCol; x++){
          const id = map[y][x];
          let color = '#a3bf8f';
          if (id===1) color='#7a6855'; else if (id===3) color='#8aab79'; else if (id===4) color='#6b8e23';
          ctx.fillStyle = color; ctx.fillRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
        }
      }
    }

    function drawRosetsu(p){
      ctx.save(); ctx.translate(p.x + p.size/2, p.y + p.size/2);
      if (p.isMoving) ctx.translate(0, Math.sin(Date.now()/100)*2);
      ctx.fillStyle='white'; ctx.strokeStyle='black'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.ellipse(0, p.size*0.1, p.size*0.28, p.size*0.4, 0, 0, Math.PI*2); ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.ellipse(0, -p.size*0.2, p.size*0.35, p.size*0.25, 0, 0, Math.PI*2); ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(-p.size*0.2, -p.size*0.3); ctx.quadraticCurveTo(-p.size*0.4, -p.size*0.5, -p.size*0.3, -p.size*0.15); ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(p.size*0.2, -p.size*0.3); ctx.quadraticCurveTo(p.size*0.4, -p.size*0.5, p.size*0.3, -p.size*0.15); ctx.fill(); ctx.stroke();
      ctx.fillStyle='black'; ctx.beginPath(); ctx.arc(-p.size*0.1, -p.size*0.2, 1.6, 0, Math.PI*2); ctx.arc(p.size*0.1, -p.size*0.2, 1.6, 0, Math.PI*2); ctx.arc(0, -p.size*0.15, 1.6, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle='#FF9800'; ctx.beginPath(); ctx.ellipse(0, p.size*0.15, p.size*0.05, p.size*0.12, 0, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle='#FF7043'; ctx.beginPath(); ctx.moveTo(0, p.size*0.05); ctx.lineTo(-p.size*0.08, p.size*0.02); ctx.lineTo(p.size*0.08, p.size*0.02); ctx.closePath(); ctx.fill();
      ctx.restore();
    }

    function drawKomaru(npc){
      ctx.save(); ctx.translate(npc.x + TILE_SIZE/2, npc.y + TILE_SIZE/2); const p={size:TILE_SIZE*.9};
      ctx.fillStyle='white'; ctx.strokeStyle='black'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.ellipse(0, p.size*.15, p.size*.28, p.size*.4, 0, 0, Math.PI*2); ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.ellipse(0, -p.size*.2, p.size*.35, p.size*.25, 0, 0, Math.PI*2); ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(-p.size*.2, -p.size*.3); ctx.quadraticCurveTo(-p.size*.4, -p.size*.45, -p.size*.35, -p.size*.15); ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(p.size*.2, -p.size*.3); ctx.quadraticCurveTo(p.size*.4, -p.size*.45, p.size*.35, -p.size*.15); ctx.fill(); ctx.stroke();
      ctx.fillStyle='black'; ctx.beginPath(); ctx.arc(-p.size*.12, -p.size*.2, 1.5, 0, Math.PI*2); ctx.arc(p.size*.12, -p.size*.2, 1.5, 0, Math.PI*2); ctx.arc(0, -p.size*.15, 1.5, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle='black'; ctx.lineWidth=1.5; ctx.beginPath(); ctx.moveTo(-p.size*.1, -p.size*.1); ctx.quadraticCurveTo(0, -p.size*.07, p.size*.1, -p.size*.1); ctx.stroke();
      ctx.restore();
    }

    function drawTetsuji(npc){
      ctx.save(); ctx.translate(npc.x + TILE_SIZE/2, npc.y + TILE_SIZE/2); const p={size:TILE_SIZE};
      ctx.fillStyle='#f5deb3'; ctx.strokeStyle='black'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.ellipse(0, p.size*.25, p.size*.5, p.size*.3, 0, 0, Math.PI*2); ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.ellipse(0, -p.size*.1, p.size*.4, p.size*.28, 0, 0, Math.PI*2); ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.ellipse(-p.size*.35, -p.size*.1, p.size*.16, p.size*.14, 0, 0, Math.PI*2); ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.ellipse(p.size*.35, -p.size*.1, p.size*.16, p.size*.14, 0, 0, Math.PI*2); ctx.fill(); ctx.stroke();
      ctx.fillStyle='#3d3532'; ctx.beginPath(); ctx.ellipse(0, 0, p.size*.25, p.size*.1, 0, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle='black'; ctx.beginPath(); ctx.arc(-p.size*.15, -p.size*.12, p.size*.05, 0, Math.PI*2); ctx.arc(p.size*.15, -p.size*.12, p.size*.05, 0, Math.PI*2); ctx.arc(0, p.size*.02, p.size*.04, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }

    function drawNPCs(){ npcs.forEach(n=>{ if(n.id==='komaru') drawKomaru(n); else if(n.id==='tetsuji') drawTetsuji(n); }); }

    function drawGlitches(){
      const colors=['#ff00ff','#ff99ff','#ffffff','#ff99ff'];
      glitches.forEach(g=>{
        if(!g.fixed){ g.flicker=(g.flicker+1)|0; ctx.globalAlpha=0.7 + Math.sin(Date.now()/200)*0.3;
          if(g.id==='ball'){
            ctx.fillStyle='white'; ctx.beginPath(); ctx.arc(g.x+TILE_SIZE/2, g.y+TILE_SIZE/2, TILE_SIZE/3, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = colors[(g.flicker>>>3)%colors.length]; ctx.lineWidth=3;
            ctx.beginPath(); ctx.arc(g.x+TILE_SIZE/2, g.y+TILE_SIZE/2, TILE_SIZE/4, Math.PI*0.2, Math.PI*0.8); ctx.stroke();
            ctx.beginPath(); ctx.arc(g.x+TILE_SIZE/2, g.y+TILE_SIZE/2, TILE_SIZE/4, Math.PI*1.2, Math.PI*1.8); ctx.stroke();
          } else {
            ctx.fillStyle = colors[(g.flicker>>>3)%colors.length]; ctx.fillRect(g.x, g.y, g.size, g.size);
          }
          ctx.globalAlpha=1;
        }
      });
    }

    // ===== Logic =====
    function isBlocked(px, py, size){
      const margin=2; const corners=[
        {x:px+margin, y:py+margin},
        {x:px+size-margin, y:py+margin},
        {x:px+margin, y:py+size-margin},
        {x:px+size-margin, y:py+size-margin}
      ];
      for(const c of corners){
        const tx = Math.floor(c.x / TILE_SIZE), ty = Math.floor(c.y / TILE_SIZE);
        const id = map[ty]?.[tx];
        if(id===1 || id===3 || id===4 || id===5 || id===6) return true;
      }
      return false;
    }

    function movePlayer(dx, dy){
      const nx=player.x+dx, ny=player.y+dy;
      if(!isBlocked(nx, player.y, player.size)) player.x=nx;
      if(!isBlocked(player.x, ny, player.size)) player.y=ny;
    }

    function update(){
      player.isMoving=false; let dx=0, dy=0;
      if(keys.ArrowUp) { dy -= player.speed; player.isMoving=true; }
      if(keys.ArrowDown){ dy += player.speed; player.isMoving=true; }
      if(keys.ArrowLeft){ dx -= player.speed; player.isMoving=true; }
      if(keys.ArrowRight){ dx += player.speed; player.isMoving=true; }
      movePlayer(dx, dy);
    }

    function updateGlitches(){
      glitches.forEach(g=>{
        if(g.id==='ball' && !g.fixed && tetsujiQuestAccepted){
          if(!g.vx && !g.vy){ g.vx = (Math.random()-.5)*5+1; g.vy=(Math.random()-.5)*5+1; }
          g.x += g.vx; g.y += g.vy;
          const m=TILE_SIZE; if(g.x<m || g.x+g.size>world.w-m) g.vx*=-1; if(g.y<m || g.y+g.size>world.h-m) g.vy*=-1;
          const dist = Math.hypot((player.x+player.size/2)-(g.x+TILE_SIZE/2), (player.y+player.size/2)-(g.y+TILE_SIZE/2));
          if(dist < player.size/2 + (g.size/3)){ g.fixed=true; handleGlitchFix('ball'); }
        }
      });
    }

    function showDialogue(text, duration=3000, speaker='ロセツ', isEnd=false){
      clearTimeout(dialogueTimeout);
      let color='text-pink-500'; if(speaker==='komaru') color='text-green-600'; if(speaker==='tetsuji') color='text-yellow-700';
      const speakerName = { komaru:'コマル先輩', tetsuji:'鉄二', 'ロセツ':'ロセツ' }[speaker] || 'ロセツ';
      const html = `
        <div class="dialogue-box bg-white bg-opacity-90 p-3 rounded-xl shadow-xl border-2 border-gray-300 max-w-md w-[92%] pointer-events-auto">
          <p class="text-gray-800 font-bold"><span class="${color}">${speakerName}:</span> ${text}</p>
          ${isEnd?'<p class="text-center text-sm mt-2 text-blue-600">クリアおめでとう！ - ページをリロードしてリスタート</p>':''}
        </div>`;
      dialogueEl.innerHTML = html;
      dialogueTimeout = setTimeout(()=>{ dialogueEl.innerHTML=''; }, duration);
    }

    function interact(){
      let acted=false;
      npcs.forEach(n=>{
        const dist = Math.hypot((player.x+player.size/2)-(n.x+TILE_SIZE/2), (player.y+player.size/2)-(n.y+TILE_SIZE/2));
        if(dist < TILE_SIZE*1.2){
          if(n.id==='tetsuji' && !tetsujiQuestAccepted){
            tetsujiQuestAccepted=true; showDialogue(n.dialogue, 3000, n.id);
            setTimeout(()=>{ showDialogue('大変だ！あのボール、すごい勢いで動き出したぞ！', 3000, 'ロセツ'); }, 3100);
          } else { showDialogue(n.dialogue, 4000, n.id); }
          acted=true;
        }
      });
      if(acted) return;
      glitches.forEach(g=>{
        if(g.id==='normal' && !g.fixed){
          const dist = Math.hypot((player.x+player.size/2)-(g.x+TILE_SIZE/2), (player.y+player.size/2)-(g.y+TILE_SIZE/2));
          if(dist < TILE_SIZE){ g.fixed=true; acted=true; handleGlitchFix('normal'); }
        }
      });
      if(!acted) showDialogue('クンクン…特に何もないみたいだ。', 1800, 'ロセツ');
    }

    function handleGlitchFix(id){
      if(id==='ball'){
        showDialogue('この野球ボール…鉄二くんのだ！返してあげなきゃ！', 2600, 'ロセツ');
        const t = npcs.find(n=>n.id==='tetsuji'); if(t) t.dialogue = 'わー！僕のボールだ！ありがとう、ロセちゃん！君はヒーローだね！';
      } else { showDialogue('よし、世界のバグを直した！', 2200, 'ロセツ'); }
      checkWin();
    }

    function checkWin(){ if(glitches.every(g=>g.fixed)) showDialogue('やった！全部のバグを直したぞ！これでみんな安心だ！', 4800, 'ロセツ', true); }

    // ===== Controls =====
    function setupControls(){
      const press = k=>{ keys[k]=true; if(!gameStarted) gameStarted=true; };
      const release = k=>{ keys[k]=false; };
      const S=[["btn-up","ArrowUp"],["btn-down","ArrowDown"],["btn-left","ArrowLeft"],["btn-right","ArrowRight"]];
      for(const [id,key] of S){ const b=document.getElementById(id); b.addEventListener('pointerdown',e=>{e.preventDefault(); press(key);}); b.addEventListener('pointerup',e=>{e.preventDefault(); release(key);}); b.addEventListener('pointerleave',e=>{e.preventDefault(); release(key);}); }
      document.getElementById('btn-action').addEventListener('click', e=>{ e.preventDefault(); if(!gameStarted) gameStarted=true; interact(); });
      // Keyboard (for desktop test)
      window.addEventListener('keydown', e=>{ if(e.key.startsWith('Arrow')) { keys[e.key]=true; if(!gameStarted) gameStarted=true; }});
      window.addEventListener('keyup', e=>{ if(e.key.startsWith('Arrow')) { keys[e.key]=false; }});
      // Tap to start
      canvas.addEventListener('touchstart', ()=>{ if(!gameStarted){ gameStarted=true; showDialogue('お外の様子が変だ…パトロールしなきゃ！', 3000); } }, { once:false });
    }

    // ===== Game Loop =====
    function gameLoop(){
      update();
      updateGlitches();
      clampCameraToPlayer(player.x + player.size/2, player.y + player.size/2);
      beginFrame();
      drawMap();
      drawNPCs();
      drawGlitches();
      drawRosetsu(player);
      endFrame();
      requestAnimationFrame(gameLoop);
    }

    function startGame(){
      setupControls();
      showDialogue('ゲーム画面をタップしてスタート！', 3500, 'システム');
      clampCameraToPlayer(player.x, player.y);
      gameLoop();
    }

    // Relayout on rotate/resize
    window.addEventListener('resize', ()=>{ layoutCanvas(); });
  </script>
</body>
</html>
