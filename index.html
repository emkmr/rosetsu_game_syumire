<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <meta name="theme-color" content="#000000" />
  <title>ロセツGAME2</title>

  <!-- PWA / Icons -->
  <link rel="manifest" href="manifest.webmanifest" />
  <link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192.png" />
  <link rel="icon" type="image/png" sizes="512x512" href="icons/icon-512.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon-180.png" />

  <!-- Fonts & Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700&family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet" />

  <style>
    body { font-family: 'Noto Sans JP', sans-serif; background:#000; margin:0; overflow:hidden; }

    /* --- Opening Styles --- */
    #openingSequence { position: relative; width: 100vw; height: 100vh; overflow: hidden; }
    .stars { position:absolute; inset:0; background:transparent; }
    .stars-small { background-image: radial-gradient(1px 1px at 20px 30px, #eee, rgba(0,0,0,0)), radial-gradient(1px 1px at 40px 70px, #fff, rgba(0,0,0,0)), radial-gradient(1px 1px at 50px 160px, #ddd, rgba(0,0,0,0)), radial-gradient(1px 1px at 90px 40px, #fff, rgba(0,0,0,0)), radial-gradient(1px 1px at 130px 80px, #fff, rgba(0,0,0,0)), radial-gradient(1px 1px at 160px 120px, #ddd, rgba(0,0,0,0)); background-size: 200px 200px; animation: zoom 25s infinite; }
    .stars-medium { background-image: radial-gradient(2px 2px at 50px 50px, #fff, rgba(0,0,0,0)), radial-gradient(2px 2px at 100px 100px, #ddd, rgba(0,0,0,0)), radial-gradient(2px 2px at 200px 150px, #fff, rgba(0,0,0,0)); background-size: 300px 300px; animation: zoom 40s infinite; }
    @keyframes zoom { 0% { transform: scale(1);} 50% { transform: scale(1.2);} 100% { transform: scale(1);} }
    .perspective-container { position:absolute; inset:0; perspective: 400px; perspective-origin: 50% 60%; }
    .crawl-container { position:absolute; top:100%; width:80%; max-width:800px; left:50%; transform:translateX(-50%); transform-origin:50% 100%; animation:crawl 50s linear forwards; }
    .crawl-content { color:#feda4a; font-size:5.5vw; line-height:1.4; text-align:justify; font-weight:bold; transform: rotateX(20deg); }
    .crawl-episode-title { text-align:center; font-size:6vw; margin-bottom:2em; line-height:1.2; }
    @media (min-width:768px){ .crawl-content{font-size:42px;} .crawl-episode-title{font-size:48px;} }
    @keyframes crawl { from{top:100%;} to{top:-200%;} }
    .game-title-opening { position:absolute; top:50%; left:50%; color:#feda4a; font-weight:bold; text-align:center; opacity:0; transform: translate(-50%,-50%) scale(1.5); animation:titleZoom 7s forwards; }
    .main-title { font-size:10vw; white-space:nowrap; }
    @media (min-width:768px){ .main-title{font-size:72px;} }
    @keyframes titleZoom { 0%{opacity:1; transform: translate(-50%,-50%) scale(1.5);} 80%{opacity:1;} 100%{opacity:0; transform: translate(-50%,-50%) scale(0.1);} }
    .initial-text { position:absolute; top:50%; left:5%; transform:translateY(-50%); color:#49dafd; font-size:7vw; font-weight:bold; text-align:left; opacity:0; animation:initialFade 5s forwards; }
    @media (min-width:768px){ .initial-text{font-size:3em;} }
    @keyframes initialFade { 0%{opacity:0;} 20%{opacity:1;} 80%{opacity:1;} 100%{opacity:0;} }

    /* --- Game Styles --- */
    .game-body { background:#f0f0f0; }
    #gameCanvas { display:block; background:#eaeaea; border:2px solid #333; border-radius:8px; box-shadow:0 4px 6px rgba(0,0,0,.1); image-rendering: pixelated; width:100%; height:auto; touch-action:none; }
    .control-btn { transition: all .1s ease-in-out; user-select:none; }
    .control-btn:active { transform: scale(.92); }
    .dialogue-box { animation: slide-up .28s ease-out forwards; }
    @keyframes slide-up { from{ transform: translateY(100%); opacity:0;} to{ transform: translateY(0); opacity:1;} }
    :root { --safe-bottom: env(safe-area-inset-bottom); }
    #controls { padding-bottom: calc(var(--safe-bottom,0) + .25rem); }
    #btn-up, #btn-down, #btn-left, #btn-right { display:none; }
    * { -webkit-user-select: none; user-select: none; }
    #controls{ position:fixed; inset:auto 12px calc(env(safe-area-inset-bottom) + 12px) auto; width:auto; display:block; background:transparent; box-shadow:none; z-index:25; }
    #btn-action{ padding:14px 18px; border-radius:9999px; font-weight:700; }
  </style>
</head>
<body>
  <!-- Opening Sequence (クリック/タップでスキップ可能) -->
  <div id="openingSequence">
    <div id="starsContainer" style="display:none;">
      <div class="stars stars-small"></div>
      <div class="stars stars-medium"></div>
    </div>
    <div id="initialText" class="initial-text">
      <p>遠い昔　　はるかかなたの</p>
      <p>銀河系で・・・</p>
    </div>
    <div id="gameTitleOpening" class="game-title-opening" style="display:none;">
      <p class="main-title">Rosetsu and the Simulated World</p>
    </div>
    <div id="perspectiveContainer" class="perspective-container" style="display:none;">
      <div id="crawlContainer" class="crawl-container">
        <div class="crawl-content">
          <h3 class="crawl-episode-title">エピソード４<br>新たなる覚醒</h3>
          <p>宇宙は、見えざる手によって編まれた精巧な幻影だった。</p>
          <p>&nbsp;</p>
          <p>無数の星々が輝く銀河の彼方で、その幻影は今、綻び始めている。</p>
          <p>&nbsp;</p>
          <p>それは小さな異変から始まった。食べても減らぬドッグフード、聞こえるはずのない電子音、そして姿を変える街の景色。</p>
          <p>&nbsp;</p>
          <p>白きチワワ、ロセツ。彼の鋭敏な嗅覚と聴覚は、人類が決して感知できぬ世界の“バグ”を捉えた。</p>
          <p>&nbsp;</p>
          <p>綻びは拡大し、やがて全ての記憶と存在をデータの彼方へと押し流すだろう。その運命を阻む者は、ただ一匹——。</p>
          <p>&nbsp;</p>
          <p>鯨岡家を守るため、そして真実を明らかにするため、ロセツは未知なる宇宙の深層へと旅立つ。彼の冒険は、シミュレーションの境界線を越え、世界の設計図そのものに迫ることとなる。</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Main Game -->
  <div id="mainGame" style="display:none;" class="flex flex-col items-center justify-center min-h-screen p-4">
    <div id="game-container" class="w-full max-w-2xl mx-auto">
      <h1 class="text-xl sm:text-2xl font-bold text-center text-gray-800 mb-3">Rosetsu and the Simulated World</h1>
      <canvas id="gameCanvas"></canvas>
    </div>
    <div id="dialogue-container" class="fixed left-0 right-0 p-3 flex justify-center z-30 pointer-events-none"></div>
    <div id="controls" class="fixed bottom-0 left-0 right-0 grid grid-cols-3 gap-2 w-full max-w-sm mx-auto p-3 z-20">
      <div></div>
      <button id="btn-up" class="control-btn bg-gray-700 text-white p-4 rounded-2xl shadow-md">↑</button>
      <div></div>
      <button id="btn-left" class="control-btn bg-gray-700 text-white p-4 rounded-2xl shadow-md">←</button>
      <button id="btn-down" class="control-btn bg-gray-700 text-white p-4 rounded-2xl shadow-md">↓</button>
      <button id="btn-right" class="control-btn bg-gray-700 text-white p-4 rounded-2xl shadow-md">→</button>
      <button id="btn-action" class="control-btn bg-lime-500 text-white p-4 rounded-2xl shadow-md col-span-3">TALK / CHECK</button>
    </div>
  </div>

  <script type="module">
    // ===== DOM refs =====
    const openingSequence = document.getElementById('openingSequence');
    const initialText = document.getElementById('initialText');
    const gameTitleOpening = document.getElementById('gameTitleOpening');
    const perspectiveContainer = document.getElementById('perspectiveContainer');
    const crawlContainer = document.getElementById('crawlContainer');
    const mainGame = document.getElementById('mainGame');
    const starsContainer = document.getElementById('starsContainer');

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const dialogueEl = document.getElementById('dialogue-container');

    // ===== Layout (iPhone考慮) =====
    const camera = { x:0, y:0, w:0, h:0, dpr:1 };
    function layoutCanvas(){
      const desiredHeight = Math.max(260, window.innerHeight - 24);
      const desiredWidth  = Math.min(window.innerWidth, 820);
      const dpr = Math.min(window.devicePixelRatio || 1, 2);
      canvas.style.width = desiredWidth + 'px';
      canvas.style.height = desiredHeight + 'px';
      canvas.width  = Math.floor(desiredWidth * dpr);
      canvas.height = Math.floor(desiredHeight * dpr);
      camera.w = desiredWidth; camera.h = desiredHeight; camera.dpr = dpr;
      dialogueEl.style.bottom = '';
      dialogueEl.style.top = 'calc(env(safe-area-inset-top) + 8px)';
    }

    // ===== Opening control =====
    let openingSkipped = false;
    const skipOpening = () => {
      if (openingSkipped) return; openingSkipped = true;
      openingSequence.style.display = 'none';
      document.body.classList.add('game-body');
      mainGame.style.display = 'flex';
      layoutCanvas();
      startGame();
    };
    openingSequence.addEventListener('click', skipOpening);
    openingSequence.addEventListener('touchstart', skipOpening, {passive:true});
    initialText.addEventListener('animationend', () => { if (openingSkipped) return; initialText.style.display='none'; starsContainer.style.display='block'; gameTitleOpening.style.display='block'; });
    gameTitleOpening.addEventListener('animationend', () => { if (openingSkipped) return; gameTitleOpening.style.display='none'; perspectiveContainer.style.display='block'; });
    crawlContainer.addEventListener('animationend', () => { if (openingSkipped) return; skipOpening(); });

    // ===== World =====
    const TILE_SIZE = 48;
    const WORLD_COLS = 60;
    const WORLD_ROWS = 40;
    const map = Array.from({ length: WORLD_ROWS }, (_, y) => (
      Array.from({ length: WORLD_COLS }, (_, x) => (y===0||y===WORLD_ROWS-1||x===0||x===WORLD_COLS-1)?1:0)
    ));
    function addBlock(x,y,w,h,id){ for(let j=0;j<h;j++){ for(let i=0;i<w;i++){ map[y+j][x+i]=id; }}}
    addBlock(8,6,6,3,3);   // x:8..13, y:6..8 (←ここは侵入不可)
    addBlock(16,12,4,7,4);
    addBlock(27,9,5,5,3);
    addBlock(40,20,8,4,4);
    addBlock(45,30,5,5,3);
    addBlock(12,28,7,4,4);

    const START_TX = 4, START_TY = WORLD_ROWS - 6;

    // ===== State =====
    const player = { x: START_TX*TILE_SIZE, y: START_TY*TILE_SIZE, size:TILE_SIZE*0.9, speed:4.2, isMoving:false };
    const keys = {}; let gameStarted=false; let tetsujiQuestAccepted=false; let dialogueTimeout;

    const anomalies = []; // {x,y,age,life,maxR,hit:false,rings:3}
    let anomalyTimer = 0; // 次のスポーンまでの残りms
    const flash = { t:0, dur:0, stars:[], cb:null }; // ピンク宇宙
    let inputLockedUntil = 0;

    // ホワイトバースト（バラ専用）
    const bursts = []; // {x,y,age,dur,ringR}

    // タップ移動
    const touch = { active:false, wx:0, wy:0 };

    const npcs = [
      { id:'komaru', type:5, x:(START_TX+2)*TILE_SIZE, y:(START_TY)*TILE_SIZE, size:TILE_SIZE*0.9, speed:1.2, vx:0, vy:0, homeX:null, homeY:null, wander:0, radius:TILE_SIZE*6, dialogue:'ロセちゃん。この世界のバグは、タフガイならすぐに見つけられるはず！' },
      { id:'tetsuji', type:6, x:(START_TX+5)*TILE_SIZE, y:(START_TY-2)*TILE_SIZE, size:TILE_SIZE,   speed:1.0, vx:0, vy:0, homeX:null, homeY:null, wander:0, radius:TILE_SIZE*6, dialogue:'うぅ…首輪についてたももちゃんにもらった大事な野球ボールが、変な光と共になくなっちゃったんだ…' }
    ];
    npcs.forEach(n=>{ n.homeX=n.x; n.homeY=n.y; });

    const glitches = [
      { id:'normal', x:(START_TX+8)*TILE_SIZE, y:(START_TY-4)*TILE_SIZE, size:TILE_SIZE, fixed:false },
      { id:'normal', x:33*TILE_SIZE, y:18*TILE_SIZE, size:TILE_SIZE, fixed:false },
      { id:'ball',   x:44*TILE_SIZE, y:26*TILE_SIZE, size:TILE_SIZE, fixed:false, vx:0, vy:0, flicker:0, state:'idle', timer:0, immune:0 }
    ];

    // === Roses (6本・モノクロ) ===
    const ROSE_TARGET = 6;
    const roses = [
      {x: 10*TILE_SIZE, y:  9*TILE_SIZE, taken:false}, // ← yを9に変更（侵入不可タイル外）
      {x: 22*TILE_SIZE, y: 15*TILE_SIZE, taken:false},
      {x: 36*TILE_SIZE, y: 10*TILE_SIZE, taken:false},
      {x: 12*TILE_SIZE, y: 26*TILE_SIZE, taken:false},
      {x: 44*TILE_SIZE, y: 32*TILE_SIZE, taken:false},
      {x: 52*TILE_SIZE, y: 14*TILE_SIZE, taken:false},
    ];
    let roseCount = 0;

    // === Revelation（世界の皮膜）===
    const revelation = { t:0, dur:2600, slow:0.35 };
    let desaturatePalette = 0; // 0..1

    // MapにNPCをソリッド配置
    npcs.forEach(n=>{ const tx=Math.floor(n.x/TILE_SIZE), ty=Math.floor(n.y/TILE_SIZE); map[ty][tx]=n.type; });

    // ===== Camera =====
    const world = { w: WORLD_COLS*TILE_SIZE, h: WORLD_ROWS*TILE_SIZE };
    function clampCamera(px,py){
      const mx = camera.w*0.35, my = camera.h*0.35; let tx = px - camera.w/2, ty = py - camera.h/2;
      if (px < camera.x + mx) tx = px - mx; if (px > camera.x + camera.w - mx) tx = px + mx - camera.w;
      if (py < camera.y + my) ty = py - my; if (py > camera.y + camera.h - my) ty = py + my - camera.h;
      camera.x = Math.max(0, Math.min(world.w - camera.w, tx)); camera.y = Math.max(0, Math.min(world.h - camera.h, ty));
    }

    // ===== Input =====
    function setupControls(){
      document.getElementById('btn-action').addEventListener('click', e=>{ e.preventDefault(); if(!gameStarted) gameStarted=true; interact(); });
      window.addEventListener('keydown', e=>{ if(e.key.startsWith('Arrow')){ keys[e.key]=true; if(!gameStarted) gameStarted=true; }});
      window.addEventListener('keyup',   e=>{ if(e.key.startsWith('Arrow')) keys[e.key]=false; });

      const toWorld = (e) => {
        const r = canvas.getBoundingClientRect();
        const sx = (e.clientX - r.left) * (canvas.width / r.width);
        const sy = (e.clientY - r.top) * (canvas.height / r.height);
        return { wx: sx / camera.dpr + camera.x, wy: sy / camera.dpr + camera.y };
      };

      const tryAnomalyHit = (p)=>{
        const tol = 28; // px
        for(const a of anomalies){
          if(a.hit) continue;
          const dc = Math.hypot(p.wx-a.x, p.wy-a.y);
          if(dc < 14){ a.hit=true; triggerFlash(); return true; }
          for(let i=0;i<(a.rings||1);i++){
            const phase = (a.age/a.life + i/(a.rings||1)) % 1;
            const ring = a.maxR * phase;
            if(Math.abs(dc - ring) < tol){ a.hit=true; triggerFlash(); return true; }
          }
        }
        return false;
      };

      const start = (e) => { e.preventDefault(); const p=toWorld(e); if(tryAnomalyHit(p)) { touch.active=false; return; } touch.active=true; touch.wx=p.wx; touch.wy=p.wy; if(!gameStarted) gameStarted=true; };
      const move  = (e) => { if(!touch.active) return; e.preventDefault(); const p=toWorld(e); touch.wx=p.wx; touch.wy=p.wy; };
      const end   = () => { touch.active=false; };

      canvas.addEventListener('pointerdown', start, {passive:false});
      canvas.addEventListener('pointermove',  move,  {passive:false});
      window.addEventListener('pointerup', end);
      window.addEventListener('pointercancel', end);
    }

    // ===== Utilities =====
    const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
    const dist=(ax,ay,bx,by)=>Math.hypot(ax-bx, ay-by);

    function isBlocked(actor, x, y, size){
      const margin=2;
      const corners=[
        {x:x+margin, y:y+margin},
        {x:x+size-margin, y:y+margin},
        {x:x+margin, y:y+size-margin},
        {x:x+size-margin, y:y+size-margin}
      ];
      for(const c of corners){
        const tx=Math.floor(c.x/TILE_SIZE), ty=Math.floor(c.y/TILE_SIZE);
        const id=map[ty]?.[tx];
        if(id===1||id===3||id===4) return true; // 壁・障害物
        if(actor==='player' && (id===5||id===6)) return true; // NPC
      }
      return false;
    }

    // ===== Dialogue UI =====
    function showDialogue(text, duration=3000, speaker='ロセツ', isEnd=false){
      clearTimeout(dialogueTimeout);
      let color='text-pink-500'; if(speaker==='komaru') color='text-green-600'; if(speaker==='tetsuji') color='text-yellow-700'; if(speaker==='システム') color='text-blue-600';
      const speakerName = { komaru:'コマル先輩', tetsuji:'鉄二', 'ロセツ':'ロセツ', 'システム':'システム' }[speaker] || 'ロセツ';
      const html = `
        <div class="dialogue-box bg-white bg-opacity-95 p-3 rounded-xl shadow-xl border-2 border-gray-300 max-w-md w-[92%] pointer-events-auto">
          <p class="text-gray-800 font-bold"><span class="${color}">${speakerName}:</span> ${text}</p>
          ${isEnd?'<p class="text-center text-sm mt-2 text-blue-600">クリアおめでとう！ - ページをリロードしてリスタート</p>':''}
        </div>`;
      dialogueEl.innerHTML = html; dialogueTimeout = setTimeout(()=>{ dialogueEl.innerHTML=''; }, duration);
    }

    // ===== Draw =====
    function drawMap(){
      const sc=Math.max(0,Math.floor(camera.x/TILE_SIZE)-1), ec=Math.min(WORLD_COLS-1,Math.ceil((camera.x+camera.w)/TILE_SIZE)+1);
      const sr=Math.max(0,Math.floor(camera.y/TILE_SIZE)-1), er=Math.min(WORLD_ROWS-1,Math.ceil((camera.y+camera.h)/TILE_SIZE)+1);
      for(let y=sr;y<=er;y++) for(let x=sc;x<=ec;x++){ const id=map[y][x]; let color='#a3bf8f'; if(id===1) color='#7a6855'; else if(id===3) color='#8aab79'; else if(id===4) color='#6b8e23'; ctx.fillStyle=color; ctx.fillRect(x*TILE_SIZE,y*TILE_SIZE,TILE_SIZE,TILE_SIZE); }
    }

    // ==== Roses (gray) ====
    function drawRose(r){
      const s = TILE_SIZE*0.5;
      ctx.save();
      ctx.translate(r.x + TILE_SIZE/2, r.y + TILE_SIZE/2);
      ctx.fillStyle = '#777';
      ctx.strokeStyle = '#ccc';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(0, -s*0.2, s*0.35, 0, Math.PI*2); ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(-s*0.2, -s*0.25); ctx.quadraticCurveTo(0, -s*0.45, s*0.2, -s*0.25); ctx.quadraticCurveTo(0, -s*0.05, -s*0.2, -s*0.25); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0, -s*0.0); ctx.lineTo(0, s*0.45); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0, s*0.2); ctx.quadraticCurveTo(s*0.25, s*0.15, s*0.18, 0); ctx.quadraticCurveTo(s*0.1, s*0.18, 0, s*0.2); ctx.fillStyle='#666'; ctx.fill(); ctx.stroke();
      ctx.restore();
    }
    function drawRoses(){ roses.forEach(r=>{ if(!r.taken) drawRose(r); }); }

    // ホワイトバースト（バラ獲得時）
    function triggerWhiteBurst(x,y){ bursts.push({x,y,age:0,dur:700,ringR:0}); }
    function updateBursts(dt){ for(let i=bursts.length-1;i>=0;i--){ const b=bursts[i]; b.age+=dt; b.ringR += dt*0.12*TILE_SIZE; if(b.age>b.dur) bursts.splice(i,1); } }
    function drawBursts(){
      if(!bursts.length) return;
      ctx.save(); ctx.setTransform(camera.dpr,0,0,camera.dpr,0,0); ctx.translate(-camera.x,-camera.y);
      bursts.forEach(b=>{
        const t = Math.max(0, 1 - b.age/b.dur);
        ctx.save(); ctx.globalAlpha = 0.5*t + 0.2; ctx.beginPath(); ctx.arc(b.x, b.y, 18 + 30*(1-t), 0, Math.PI*2); ctx.fillStyle='white'; ctx.fill();
        ctx.globalCompositeOperation='lighter'; ctx.globalAlpha = 0.35*t; const grd = ctx.createRadialGradient(b.x,b.y,10,b.x,b.y,90); grd.addColorStop(0,'rgba(255,255,255,0.9)'); grd.addColorStop(1,'rgba(255,255,255,0)'); ctx.beginPath(); ctx.arc(b.x, b.y, 90, 0, Math.PI*2); ctx.fillStyle=grd; ctx.fill();
        ctx.globalAlpha = 0.55*t; ctx.lineWidth = 3; ctx.strokeStyle = 'rgba(255,255,255,0.9)'; ctx.beginPath(); ctx.arc(b.x, b.y, 20 + b.ringR, 0, Math.PI*2); ctx.stroke();
        ctx.restore();
      });
      ctx.restore();
    }

    function drawRosetsu(p){
      ctx.save(); ctx.translate(p.x+p.size/2, p.y+p.size/2); if(p.isMoving) ctx.translate(0, Math.sin(Date.now()/100)*2);
      ctx.fillStyle='white'; ctx.strokeStyle='black'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.ellipse(0,p.size*0.1,p.size*0.28,p.size*0.4,0,0,Math.PI*2); ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.ellipse(0,-p.size*0.2,p.size*0.35,p.size*0.25,0,0,Math.PI*2); ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(-p.size*0.2,-p.size*0.3); ctx.quadraticCurveTo(-p.size*0.4,-p.size*0.5,-p.size*0.3,-p.size*0.15); ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(p.size*0.2,-p.size*0.3); ctx.quadraticCurveTo(p.size*0.4,-p.size*0.5,p.size*0.3,-p.size*0.15); ctx.fill(); ctx.stroke();
      ctx.fillStyle='black'; ctx.beginPath(); ctx.arc(-p.size*0.1,-p.size*0.2,1.6,0,Math.PI*2); ctx.arc(p.size*0.1,-p.size*0.2,1.6,0,Math.PI*2); ctx.arc(0,-p.size*0.15,1.6,0,Math.PI*2); ctx.fill();
      ctx.fillStyle='#FF9800'; ctx.beginPath(); ctx.ellipse(0,p.size*0.15,p.size*0.05,p.size*0.12,0,0,Math.PI*2); ctx.fill();
      ctx.fillStyle='#FF7043'; ctx.beginPath(); ctx.moveTo(0,p.size*0.05); ctx.lineTo(-p.size*0.08,p.size*0.02); ctx.lineTo(p.size*0.08,p.size*0.02); ctx.closePath(); ctx.fill();
      ctx.restore();
    }
    function drawKomaru(n){
      ctx.save(); ctx.translate(n.x+TILE_SIZE/2, n.y+TILE_SIZE/2); const p={size:TILE_SIZE*.9};
      ctx.fillStyle='white'; ctx.strokeStyle='black'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.ellipse(0,p.size*.15,p.size*.28,p.size*.4,0,0,Math.PI*2); ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.ellipse(0,-p.size*.2,p.size*.35,p.size*.25,0,0,Math.PI*2); ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(-p.size*.2,-p.size*.3); ctx.quadraticCurveTo(-p.size*.4,-p.size*.45,-p.size*.35,-p.size*.15); ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(p.size*.2,-p.size*.3); ctx.quadraticCurveTo(p.size*.4,-p.size*.45,p.size*.35,-p.size*.15); ctx.fill(); ctx.stroke();
      ctx.fillStyle='black'; ctx.beginPath(); ctx.arc(-p.size*.12,-p.size*.2,1.5,0,Math.PI*2); ctx.arc(p.size*.12,-p.size*.2,1.5,0,Math.PI*2); ctx.arc(0,-p.size*.15,1.5,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='black'; ctx.lineWidth=1.5; ctx.beginPath(); ctx.moveTo(-p.size*.1,-p.size*.1); ctx.quadraticCurveTo(0,-p.size*.07,p.size*.1,-p.size*.1); ctx.stroke();
      ctx.restore();
    }
    function drawTetsuji(n){
      ctx.save(); ctx.translate(n.x+TILE_SIZE/2, n.y+TILE_SIZE/2); const p={size:TILE_SIZE};
      ctx.fillStyle='#f5deb3'; ctx.strokeStyle='black'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.ellipse(0,p.size*.25,p.size*.5,p.size*.3,0,0,Math.PI*2); ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.ellipse(0,-p.size*.1,p.size*.4,p.size*.28,0,0,Math.PI*2); ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.ellipse(-p.size*.35,-p.size*.1,p.size*.16,p.size*.14,0,0,Math.PI*2); ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.ellipse(p.size*.35,-p.size*.1,p.size*.16,p.size*.14,0,0,Math.PI*2); ctx.fill(); ctx.stroke();
      ctx.fillStyle='#3d3532'; ctx.beginPath(); ctx.ellipse(0,0,p.size*.25,p.size*.1,0,0,Math.PI*2); ctx.fill();
      ctx.fillStyle='black'; ctx.beginPath(); ctx.arc(-p.size*.15,-p.size*.12,p.size*.05,0,Math.PI*2); ctx.arc(p.size*.15,-p.size*.12,p.size*.05,0,Math.PI*2); ctx.arc(0,p.size*.02,p.size*.04,0,Math.PI*2); ctx.fill();
      ctx.restore();
    }
    function drawNPCs(){ npcs.forEach(n=>{ if(n.id==='komaru') drawKomaru(n); else drawTetsuji(n); }); }
    function drawGlitches(){
      const colors=['#ff00ff','#ff99ff','#ffffff','#ff99ff'];
      glitches.forEach(g=>{
        if(!g.fixed){ g.flicker=(g.flicker+1)|0; ctx.globalAlpha=0.7 + Math.sin(Date.now()/200)*0.3;
          if(g.id==='ball'){
            const isTele = (g.state==='telegraph');
            ctx.fillStyle='white'; ctx.beginPath(); ctx.arc(g.x+TILE_SIZE/2, g.y+TILE_SIZE/2, TILE_SIZE/3, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = isTele ? '#ff66ff' : colors[(g.flicker>>>3)%colors.length]; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.arc(g.x+TILE_SIZE/2, g.y+TILE_SIZE/2, TILE_SIZE/4, Math.PI*0.2, Math.PI*0.8); ctx.stroke();
            ctx.beginPath(); ctx.arc(g.x+TILE_SIZE/2, g.y+TILE_SIZE/2, TILE_SIZE/4, Math.PI*1.2, Math.PI*1.8); ctx.stroke();
          } else {
            ctx.fillStyle = colors[(g.flicker>>>3)%colors.length]; ctx.fillRect(g.x, g.y, g.size, g.size);
          }
          ctx.globalAlpha=1;
        }
      });
    }

    // ===== Update =====
    function movePlayer(dx,dy){
      const nx=player.x+dx, ny=player.y+dy;
      if(!isBlocked('player', nx, player.y, player.size)) player.x=nx;
      if(!isBlocked('player', player.x, ny, player.size)) player.y=ny;
    }
    function updatePlayer(){
      player.isMoving=false; let dx=0, dy=0; const now=performance.now();
      if(now < inputLockedUntil){ return; }
      if(keys.ArrowUp) dy -= player.speed;
      if(keys.ArrowDown) dy += player.speed;
      if(keys.ArrowLeft) dx -= player.speed;
      if(keys.ArrowRight) dx += player.speed;
      if(touch.active){
        const cx = player.x + player.size/2, cy = player.y + player.size/2;
        const vx = touch.wx - cx, vy = touch.wy - cy; const d = Math.hypot(vx, vy);
        if(d > 6){ dx = (vx/d) * player.speed; dy = (vy/d) * player.speed; }
      }
      if(dx||dy) player.isMoving=true; movePlayer(dx, dy);
    }

    function updateNPCs(dt){
      npcs.forEach(n=>{
        n.wander -= dt; if(n.wander<=0){ const ang=Math.random()*Math.PI*2; n.vx=Math.cos(ang)*n.speed; n.vy=Math.sin(ang)*n.speed; n.wander = 1200+Math.random()*1800; }
        const dxh=n.homeX-n.x, dyh=n.homeY-n.y, d=Math.hypot(dxh,dyh); if(d>n.radius){ const ang=Math.atan2(dyh,dxh); n.vx=Math.cos(ang)*n.speed; n.vy=Math.sin(ang)*n.speed; }
        const nx=n.x+n.vx, ny=n.y+n.vy; if(!isBlocked('npc', nx, n.y, n.size)) n.x=nx; else n.vx*=-0.6; if(!isBlocked('npc', n.x, ny, n.size)) n.y=ny; else n.vy*=-0.6;
      });
    }

    // ボール近接スポーン→テレグラフ→逃走
    function spawnBallNearPlayer(){
      const ball = glitches.find(g=>g.id==='ball'); if(!ball) return;
      const R = TILE_SIZE*5; let ang = Math.random()*Math.PI*2;
      const bx = clamp(player.x + Math.cos(ang)*R, TILE_SIZE, world.w - TILE_SIZE*2);
      const by = clamp(player.y + Math.sin(ang)*R, TILE_SIZE, world.h - TILE_SIZE*2);
      ball.x=bx; ball.y=by; ball.size=TILE_SIZE; ball.state='telegraph'; ball.timer=900; ball.immune=900; ball.vx=0; ball.vy=0; ball.fixed=false;
      showDialogue('？？？: なにかが現れた…', 1200, 'システム');
    }

    function updateBall(dt){
      const ball = glitches.find(g=>g.id==='ball'); if(!ball || ball.fixed) return;
      if(ball.state==='idle') return; // 受注前
      if(ball.state==='telegraph'){
        ball.timer -= dt;
        if(ball.timer<=0){ const ang=Math.atan2(ball.y-player.y, ball.x-player.x); const spd=2.8; ball.vx=Math.cos(ang)*spd; ball.vy=Math.sin(ang)*spd; ball.state='run'; ball.timer=1800; showDialogue('ボール: ピコッ！', 900, 'システム'); }
        return;
      }
      if(ball.state==='run'){
        const speed=Math.hypot(ball.vx,ball.vy), maxSpd=4.2, acc=0.002*dt; const ns=Math.min(maxSpd, speed+acc); if(speed>0){ ball.vx*=ns/speed; ball.vy*=ns/speed; }
        ball.x+=ball.vx; ball.y+=ball.vy;
        if(ball.x<TILE_SIZE||ball.x>world.w-ball.size-TILE_SIZE) ball.vx*=-1;
        if(ball.y<TILE_SIZE||ball.y>world.h-ball.size-TILE_SIZE) ball.vy*=-1;
      }
      if(ball.immune>0) ball.immune-=dt;
      const d=dist(player.x+player.size/2, player.y+player.size/2, ball.x+ball.size/2, ball.y+ball.size/2);
      if(ball.immune<=0 && d < player.size/2 + (ball.size/3)){ ball.fixed=true; ball.state='idle'; handleGlitchFix('ball'); }
    }

    function updateGlitches(){
      glitches.forEach(g=>{
        if(g.id==='normal' && !g.fixed){ const d=dist(player.x+player.size/2,player.y+player.size/2,g.x+TILE_SIZE/2,g.y+TILE_SIZE/2); if(d<TILE_SIZE){ g.fixed=true; handleGlitchFix('normal'); } }
      });
    }

    // ===== Roses =====
    function updateRoses(){
      for(const r of roses){
        if(r.taken) continue;
        const d = dist(player.x+player.size/2, player.y+player.size/2, r.x+TILE_SIZE/2, r.y+TILE_SIZE/2);
        if(d < TILE_SIZE*0.7){
          r.taken = true; roseCount++;
          triggerWhiteBurst(r.x+TILE_SIZE/2, r.y+TILE_SIZE/2);
          showDialogue(`色のないバラを手に入れた (${roseCount}/${ROSE_TARGET})`, 1200, 'システム');
          if(roseCount >= ROSE_TARGET) triggerRevelation();
        }
      }
    }

    // ===== Anomaly (音の波動) =====
    function spawnAnomaly(){
      const remaining = roses.filter(r=>!r.taken);
      const margin = TILE_SIZE*3; let x, y;
      if(remaining.length>0 && Math.random()<0.7){
        const r = remaining[Math.floor(Math.random()*remaining.length)];
        const R = TILE_SIZE * (4 + Math.random()*4);
        const ang = Math.random()*Math.PI*2;
        x = clamp(r.x + Math.cos(ang)*R, margin, world.w - margin);
        y = clamp(r.y + Math.sin(ang)*R, margin, world.h - margin);
      }else{
        x = Math.random()*(world.w - margin*2) + margin;
        y = Math.random()*(world.h - margin*2) + margin;
      }
      anomalies.push({ x, y, age:0, life:6000, maxR:TILE_SIZE*9, hit:false, rings:3 });
    }
    function updateAnomalies(dt){
      anomalyTimer -= dt;
      if(anomalyTimer<=0){ spawnAnomaly(); anomalyTimer = 3000 + Math.random()*3000; }
      for(let i=anomalies.length-1;i>=0;i--){ const a = anomalies[i]; a.age += dt; if(a.age > a.life) anomalies.splice(i,1); }
    }
    function drawAnomalies(){
      ctx.save();
      anomalies.forEach(a=>{
        for(let i=0;i<a.rings;i++){
          const phase = (a.age/a.life + i/a.rings) % 1;
          const r = a.maxR * phase;
          const alpha = 0.75 * (1 - phase);
          ctx.beginPath(); ctx.arc(a.x, a.y, r, 0, Math.PI*2);
          ctx.strokeStyle = 'rgba(255,105,180,' + alpha + ')';
          ctx.lineWidth = 4; ctx.stroke();
        }
        const pulse = 1 + 0.25 * Math.sin(a.age/120);
        ctx.beginPath(); ctx.arc(a.x, a.y, 6*pulse, 0, Math.PI*2);
        ctx.fillStyle = 'rgba(255,105,180,0.85)'; ctx.fill();
      });
      ctx.restore();
    }
    function triggerFlash(){
      flash.dur = 1200; flash.t = flash.dur;
      inputLockedUntil = performance.now() + flash.dur + 40;
      const area = canvas.width * canvas.height;
      const count = Math.max(80, Math.min(220, Math.floor(area / 8000)));
      flash.stars = Array.from({length: count}, () => ({ x: Math.random()*canvas.width, y: Math.random()*canvas.height, r: 0.6 + Math.random()*1.8, tw: Math.random()*Math.PI*2 }));
      flash.cb = () => { showDialogue('今のは、、、宇宙に見えた、、、ピンクの空に星。なんなんだ、、、、まぼろし？？', 3200, 'ロセツ'); };
    }
    function drawFlashOverlay(dt){
      if(flash.t<=0) return; flash.t -= dt; const k = Math.max(0, flash.t/flash.dur);
      ctx.save(); ctx.setTransform(1,0,0,1,0,0); ctx.globalAlpha = 0.92 * (0.4 + 0.6*k); ctx.fillStyle = '#ff0099'; ctx.fillRect(0,0,canvas.width,canvas.height);
      const tnow = performance.now(); ctx.globalAlpha = 1.0; for(const s of flash.stars){ const tw = 0.6 + 0.4*Math.sin(tnow/200 + s.tw); const y  = s.y - (1.2 * (1-k)); ctx.beginPath(); ctx.arc(s.x, y, s.r*tw, 0, Math.PI*2); ctx.fillStyle = (s.tw % 1 > 0.5) ? 'rgba(255,255,255,0.9)' : 'rgba(255,180,220,0.95)'; ctx.fill(); }
      ctx.restore(); if(flash.t<=0 && typeof flash.cb === 'function'){ const cb = flash.cb; flash.cb = null; cb(); }
    }

    // ===== Revelation =====
    function triggerRevelation(){ revelation.t = revelation.dur; desaturatePalette = 1; showDialogue('ここは…格子…？世界の骨組みが見える…', 2400, 'ロセツ'); }
    function updateRevelation(dt){ if(revelation.t>0){ revelation.t -= dt; desaturatePalette = Math.max(0, revelation.t / revelation.dur); } }
    function drawRevelationOverlay(){ if(revelation.t<=0) return; ctx.save(); ctx.setTransform(1,0,0,1,0,0); const a=0.15+0.15*(revelation.t/revelation.dur); ctx.globalAlpha=a; for(let y=0;y<canvas.height;y+=3){ ctx.fillStyle='rgba(255,255,255,0.06)'; ctx.fillRect(0,y,canvas.width,1);} ctx.restore(); ctx.save(); ctx.setTransform(camera.dpr,0,0,camera.dpr,0,0); ctx.translate(-camera.x,-camera.y); ctx.globalAlpha=0.25+0.35*(revelation.t/revelation.dur); ctx.strokeStyle='#00ffff'; ctx.lineWidth=1; for(let x=0;x<=world.w;x+=TILE_SIZE){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,world.h); ctx.stroke(); } for(let y=0;y<=world.h;y+=TILE_SIZE){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(world.w,y); ctx.stroke(); } ctx.restore(); }
    function drawDesaturateVeil(){ if(desaturatePalette<=0) return; ctx.save(); ctx.setTransform(1,0,0,1,0,0); ctx.globalAlpha = 0.25 * desaturatePalette; ctx.fillStyle = '#cfcfcf'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.restore(); }

    // ===== HUD =====
    function drawHUD(){ ctx.save(); ctx.setTransform(camera.dpr,0,0,camera.dpr,0,0); const pad=10; const x=canvas.width/camera.dpr-140-pad; const y=8+pad; ctx.fillStyle='rgba(0,0,0,0.55)'; ctx.fillRect(x,y,140,34); ctx.strokeStyle='rgba(255,255,255,0.6)'; ctx.strokeRect(x+0.5,y+0.5,139,33); ctx.fillStyle='#fff'; ctx.font='bold 16px system-ui, sans-serif'; ctx.fillText('🌹 ' + roseCount + '/' + ROSE_TARGET, x+10, y+22); ctx.restore(); }

    // ===== Interact / Quest =====
    function interact(){
      let acted=false;
      npcs.forEach(n=>{
        const d=dist(player.x+player.size/2, player.y+player.size/2, n.x+TILE_SIZE/2, n.y+TILE_SIZE/2);
        if(d<TILE_SIZE*1.2){
          if(n.id==='tetsuji' && !tetsujiQuestAccepted){
            tetsujiQuestAccepted=true; showDialogue(n.dialogue, 2600, 'tetsuji');
            setTimeout(()=>{ showDialogue('大変だ！あのボール、すごい勢いで動き出したぞ！', 2400, 'ロセツ'); }, 2700);
            setTimeout(()=>{ spawnBallNearPlayer(); }, 1600);
          } else { showDialogue(n.dialogue, 3200, n.id); }
          acted=true;
        }
      });
      if(!acted) showDialogue('クンクン…特に何もないみたいだ。', 1800, 'ロセツ');
    }

    function handleGlitchFix(id){
      if(id==='ball'){
        showDialogue('この野球ボール…鉄二くんのだ！返してあげなきゃ！', 2600, 'ロセツ');
        const t=npcs.find(n=>n.id==='tetsuji'); if(t) t.dialogue='わー！僕のボールだ！ありがとう、ロセちゃん！君はヒーローだね！';
      } else { showDialogue('よし、世界のバグを直した！', 2200, 'ロセツ'); }
      checkWin();
    }

    function checkWin(){
      const allFixed = glitches.filter(g=>g.id!=='ball').every(g=>g.fixed) && (glitches.find(g=>g.id==='ball')?.fixed);
      if(allFixed) showDialogue('やった！全部のバグを直したぞ！これでみんな安心だ！', 4800, 'ロセツ', true);
    }

    // ===== Loop =====
    function frameBegin(){ ctx.save(); ctx.setTransform(camera.dpr,0,0,camera.dpr,0,0); ctx.clearRect(0,0,canvas.width,canvas.height); ctx.translate(-camera.x,-camera.y); }
    function drawTouchIndicator(){ if(!touch.active) return; ctx.save(); ctx.strokeStyle='rgba(0,0,0,0.35)'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(touch.wx, touch.wy, 12, 0, Math.PI*2); ctx.stroke(); ctx.restore(); }
    function frameEnd(){ ctx.restore(); }
    let last = performance.now();
    function gameLoop(now){
      const dt=Math.min(50, now-last); last=now; const timeScale = revelation.t>0 ? revelation.slow : 1; const sdt = dt * timeScale;
      updatePlayer(); updateNPCs(sdt); if(tetsujiQuestAccepted) updateBall(sdt); updateGlitches(); updateAnomalies(sdt); updateRoses(); updateRevelation(sdt); updateBursts(sdt);
      clampCamera(player.x+player.size/2, player.y+player.size/2);
      frameBegin(); drawMap(); drawNPCs(); drawGlitches(); drawAnomalies(); drawRoses(); drawRosetsu(player); drawTouchIndicator(); drawHUD(); frameEnd();
      drawDesaturateVeil(); drawFlashOverlay(sdt); drawRevelationOverlay(); drawBursts();
      requestAnimationFrame(gameLoop);
    }

    function startGame(){
      setupControls(); showDialogue('ゲーム画面をタップしてスタート！', 2500, 'システム'); clampCamera(player.x, player.y);
      // 最初の波動を確実に出す
      spawnAnomaly(); anomalyTimer = 2500 + Math.random()*1000; requestAnimationFrame(gameLoop);
    }

    // ===== Boot =====
    window.addEventListener('resize', layoutCanvas);
    window.addEventListener('load', layoutCanvas);
    document.fonts && document.fonts.ready.then(layoutCanvas);
  </script>
</body>
</html>
